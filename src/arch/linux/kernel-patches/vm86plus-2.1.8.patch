diff -ur linux-2.1.8-clean/arch/i386/kernel/ldt.c linux/arch/i386/kernel/ldt.c
--- linux-2.1.8-clean/arch/i386/kernel/ldt.c	Mon Nov 11 00:08:25 1996
+++ linux/arch/i386/kernel/ldt.c	Mon Nov 11 00:37:57 1996
@@ -75,10 +75,10 @@
 
 	copy_from_user(&ldt_info, ptr, sizeof(ldt_info));
 
-	if (ldt_info.contents == 3 || ldt_info.entry_number >= LDT_ENTRIES)
+	if ((ldt_info.contents == 3 && ldt_info.seg_not_present == 0) || ldt_info.entry_number >= LDT_ENTRIES)
 		return -EINVAL;
 
-	if (!limits_ok(&ldt_info))
+	if (!limits_ok(&ldt_info) && ldt_info.seg_not_present == 0)
 		return -EINVAL;
 
 	if (!current->ldt) {
@@ -95,7 +95,10 @@
 	
 	lp = (unsigned long *) &current->ldt[ldt_info.entry_number];
    	/* Allow LDTs to be cleared by the user. */
-   	if (ldt_info.base_addr == 0 && ldt_info.limit == 0) {
+   	if (ldt_info.base_addr == 0 && ldt_info.limit == 0 &&
+	    ldt_info.contents == 0 && ldt_info.read_exec_only == 1 &&
+	    ldt_info.seg_32bit == 0 && ldt_info.limit_in_pages == 0 &&
+	    ldt_info.seg_not_present == 1 && ldt_info.useable == 0) {
 		*lp = 0;
 		*(lp+1) = 0;
 		return 0;
@@ -110,6 +113,7 @@
 		  (ldt_info.seg_32bit << 22) |
 		  (ldt_info.limit_in_pages << 23) |
 		  ((ldt_info.seg_not_present ^1) << 15) |
+		  (ldt_info.useable << 20) |
 		  0x7000;
 	return 0;
 }
diff -ur linux-2.1.8-clean/arch/i386/kernel/signal.c linux/arch/i386/kernel/signal.c
--- linux-2.1.8-clean/arch/i386/kernel/signal.c	Mon Nov 11 00:08:25 1996
+++ linux/arch/i386/kernel/signal.c	Mon Nov 11 01:02:36 1996
@@ -82,7 +82,10 @@
 #define COPY(x) regs->x = context->x
 #define COPY_SEG(seg) \
 { unsigned int tmp = context->seg; \
-if ((tmp & 0xfffc) && (tmp & 3) != 3) goto badframe; \
+if (   (tmp & 0xfffc)     /* not a NULL selectors */ \
+    && (tmp & 0x4) != 0x4 /* not a LDT selector */ \
+    && (tmp & 3) != 3     /* not a RPL3 GDT selector */ \
+   ) goto badframe; \
 regs->x##seg = tmp; }
 #define COPY_SEG_STRICT(seg) \
 { unsigned int tmp = context->seg; \
@@ -90,7 +93,10 @@
 regs->x##seg = tmp; }
 #define GET_SEG(seg) \
 { unsigned int tmp = context->seg; \
-if ((tmp & 0xfffc) && (tmp & 3) != 3) goto badframe; \
+if (   (tmp & 0xfffc)     /* not a NULL selectors */ \
+    && (tmp & 0x4) != 0x4 /* not a LDT selector */ \
+    && (tmp & 3) != 3     /* not a RPL3 GDT selector */ \
+   ) goto badframe; \
 __asm__("mov %w0,%%" #seg: :"r" (tmp)); }
 	struct sigcontext * context;
 	struct pt_regs * regs;
diff -ur linux-2.1.8-clean/arch/i386/kernel/traps.c linux/arch/i386/kernel/traps.c
--- linux-2.1.8-clean/arch/i386/kernel/traps.c	Mon Nov 11 00:09:41 1996
+++ linux/arch/i386/kernel/traps.c	Mon Nov 11 01:13:04 1996
@@ -44,6 +44,20 @@
 	die_if_kernel(str,regs,error_code); \
 }
 
+#define DO_VM86_ERROR(trapnr, signr, str, name, tsk) \
+asmlinkage void do_##name(struct pt_regs * regs, long error_code) \
+{ \
+	if (regs->eflags & VM_MASK) { \
+		if (!handle_vm86_trap((struct vm86_regs *) regs, error_code, trapnr)) \
+			return; \
+		/* else fall through */ \
+	} \
+	tsk->tss.error_code = error_code; \
+	tsk->tss.trap_no = trapnr; \
+	force_sig(signr, tsk); \
+	die_if_kernel(str,regs,error_code); \
+}
+
 #define get_seg_byte(seg,addr) ({ \
 register unsigned char __res; \
 __asm__("push %%fs;mov %%ax,%%fs;movb %%fs:%2,%%al;pop %%fs" \
@@ -164,12 +178,12 @@
 	do_exit(SIGSEGV);
 }
 
-DO_ERROR( 0, SIGFPE,  "divide error", divide_error, current)
-DO_ERROR( 3, SIGTRAP, "int3", int3, current)
-DO_ERROR( 4, SIGSEGV, "overflow", overflow, current)
-DO_ERROR( 5, SIGSEGV, "bounds", bounds, current)
+DO_VM86_ERROR( 0, SIGFPE,  "divide error", divide_error, current)
+DO_VM86_ERROR( 3, SIGTRAP, "int3", int3, current)
+DO_VM86_ERROR( 4, SIGSEGV, "overflow", overflow, current)
+DO_VM86_ERROR( 5, SIGSEGV, "bounds", bounds, current)
 DO_ERROR( 6, SIGILL,  "invalid operand", invalid_op, current)
-DO_ERROR( 7, SIGSEGV, "device not available", device_not_available, current)
+DO_VM86_ERROR( 7, SIGSEGV, "device not available", device_not_available, current)
 DO_ERROR( 8, SIGSEGV, "double fault", double_fault, current)
 DO_ERROR( 9, SIGFPE,  "coprocessor segment overrun", coprocessor_segment_overrun, last_task_used_math)
 DO_ERROR(10, SIGSEGV, "invalid TSS", invalid_TSS, current)
@@ -206,7 +220,7 @@
 asmlinkage void do_debug(struct pt_regs * regs, long error_code)
 {
 	if (regs->eflags & VM_MASK) {
-		handle_vm86_debug((struct vm86_regs *) regs, error_code);
+		handle_vm86_trap((struct vm86_regs *) regs, error_code, 1);
 		return;
 	}
 	force_sig(SIGTRAP, current);
diff -ur linux-2.1.8-clean/arch/i386/kernel/vm86.c linux/arch/i386/kernel/vm86.c
--- linux-2.1.8-clean/arch/i386/kernel/vm86.c	Mon Nov 11 00:08:25 1996
+++ linux/arch/i386/kernel/vm86.c	Tue Nov 12 02:12:27 1996
@@ -103,16 +103,44 @@
 	flush_tlb();
 }
 
-asmlinkage int sys_vm86(struct vm86_struct * v86)
+static do_vm86_irq_handling(int subfunction, int irqnumber);
+
+asmlinkage int sys_vm86(unsigned long subfunction, struct vm86_struct * v86_)
 {
-	struct vm86_struct info;
+	struct vm86_struct info, *v86;
 	struct task_struct *tsk = current;
-	struct pt_regs * pt_regs = (struct pt_regs *) &v86;
+	struct pt_regs * pt_regs;
 
+	switch (subfunction) {
+		case VM86_ENTER:
+		case VM86_ENTER_NO_BYPASS: {
+			v86 = v86_;
+			break;
+		}
+		case VM86_REQUEST_IRQ:
+		case VM86_FREE_IRQ:
+		case VM86_GET_IRQ_BITS:
+		case VM86_GET_AND_RESET_IRQ:
+			return do_vm86_irq_handling(subfunction,(int)v86_);
+		case VM86_PLUS_INSTALL_CHECK:
+			/* NOTE: on old vm86 stuff this will return the error
+			   from copy_from_user(), because the subfunction is
+			   interpreted as (invalid) address to vm86_struct.
+			   So the installation check works.
+			 */
+			return 0;
+		default: {
+			/* old style of vm86 call */
+			v86 = (struct vm86_struct *)subfunction;
+		}	
+	}
+
+	/* we come here only for functions VM86_ENTER, VM86_ENTER_NO_BYPASS */
 	if (tsk->saved_kernel_stack)
 		return -EPERM;
 	if (copy_from_user(&info,v86,sizeof(info)))
 		return -EFAULT;
+	pt_regs = (struct pt_regs *) &subfunction;
 /*
  * make sure the vm86() system call doesn't try to do anything silly
  */
@@ -331,23 +359,55 @@
 	return_to_32bit(regs, VM86_INTx + (i << 8));
 }
 
-void handle_vm86_debug(struct vm86_regs * regs, long error_code)
-{
-#if 0
-	do_int(regs, 1, (unsigned char *) (regs->ss << 4), SP(regs));
-#else
+
+#define CHECK_IF_IN_TRAP \
+	if (vmpi.vm86dbg_active && vmpi.vm86dbg_TFpendig) \
+		pushw(ssp,sp,popw(ssp,sp) | TF_MASK);
+
+#define OLD_PT_REGS(x) /* we saved the pt_regs of vm86() call to tss.esp0 */ \
+	(((struct pt_regs *)current->tss.esp0)->x)
+
+#define IS_VM86PLUS \
+	( ((unsigned long) OLD_PT_REGS(ebx)) == VM86_ENTER)
+
+int handle_vm86_trap(struct vm86_regs * regs, long error_code, int trapno)
+{
+	if (IS_VM86PLUS) {
+		if ( (trapno==3) || (trapno==1) )
+			return_to_32bit(regs, VM86_TRAP + (trapno << 8));
+		do_int(regs, trapno, (unsigned char *) (regs->ss << 4), SP(regs));
+		return 1;
+	}
+	if (trapno !=1)
+		return 0; /* we let this handle by the calling routine */
 	if (current->flags & PF_PTRACED)
 		current->blocked &= ~(1 << (SIGTRAP-1));
 	send_sig(SIGTRAP, current, 1);
-	current->tss.trap_no = 1;
+	current->tss.trap_no = trapno;
 	current->tss.error_code = error_code;
-#endif
+	return 0;
 }
 
+#define VM86_FAULT_RETURN \
+	if (is_vm86plus) { \
+		if (vmpi.force_return_for_pic  && (VEFLAGS & IF_MASK)) \
+			return_to_32bit(regs, VM86_PICRETURN); \
+	} \
+	return;
+	                                   
 void handle_vm86_fault(struct vm86_regs * regs, long error_code)
 {
 	unsigned char *csp, *ssp;
 	unsigned long ip, sp;
+	struct vm86plus_struct *vmp=(void *)(current->tss.vm86_info);
+	int is_vm86plus=IS_VM86PLUS;
+	struct vm86plus_info_struct vmpi;
+
+	if (is_vm86plus) {
+		/* For now it's enough to get just the flag bit fields */
+		get_user(*((long *)&vmpi), (long *)&vmp->vm86plus);
+	}
+	else *((long *)&vmpi) = 0;
 
 	csp = (unsigned char *) (regs->cs << 4);
 	ssp = (unsigned char *) (regs->ss << 4);
@@ -365,58 +425,72 @@
 			SP(regs) -= 4;
 			IP(regs) += 2;
 			pushl(ssp, sp, get_vflags(regs));
-			return;
+			VM86_FAULT_RETURN;
 
 		/* popfd */
 		case 0x9d:
 			SP(regs) += 4;
 			IP(regs) += 2;
+			CHECK_IF_IN_TRAP
 			set_vflags_long(popl(ssp, sp), regs);
-			return;
+			VM86_FAULT_RETURN;
 
 		/* iretd */
 		case 0xcf:
 			SP(regs) += 12;
 			IP(regs) = (unsigned short)popl(ssp, sp);
 			regs->cs = (unsigned short)popl(ssp, sp);
+			CHECK_IF_IN_TRAP
 			set_vflags_long(popl(ssp, sp), regs);
-			return;
+			VM86_FAULT_RETURN;
+		/* need this to avoid a fallthrough */
+		default:
+			return_to_32bit(regs, VM86_UNKNOWN);
 		}
-		break;
 
 	/* pushf */
 	case 0x9c:
 		SP(regs) -= 2;
 		IP(regs)++;
 		pushw(ssp, sp, get_vflags(regs));
-		return;
+		VM86_FAULT_RETURN;
 
 	/* popf */
 	case 0x9d:
 		SP(regs) += 2;
 		IP(regs)++;
+		CHECK_IF_IN_TRAP
 		set_vflags_short(popw(ssp, sp), regs);
-		return;
+		VM86_FAULT_RETURN;
 
 	/* int xx */
-	case 0xcd:
+	case 0xcd: {
+	        int intno=popb(csp, ip);
 		IP(regs) += 2;
-		do_int(regs, popb(csp, ip), ssp, sp);
+		if (is_vm86plus && vmpi.vm86dbg_active) {
+			unsigned char b;
+			get_user(b, (char *)&vmp->vm86plus.vm86dbg_intxxtab[intno >> 3]);
+			if ( (1 << (intno &7)) & b)
+				return_to_32bit(regs, VM86_INTx + (intno << 8));
+		}
+		do_int(regs, intno, ssp, sp);
 		return;
+	}
 
 	/* iret */
 	case 0xcf:
 		SP(regs) += 6;
 		IP(regs) = popw(ssp, sp);
 		regs->cs = popw(ssp, sp);
+		CHECK_IF_IN_TRAP
 		set_vflags_short(popw(ssp, sp), regs);
-		return;
+		VM86_FAULT_RETURN;
 
 	/* cli */
 	case 0xfa:
 		IP(regs)++;
 		clear_IF(regs);
-		return;
+		VM86_FAULT_RETURN;
 
 	/* sti */
 	/*
@@ -428,11 +502,122 @@
 	case 0xfb:
 		IP(regs)++;
 		set_IF(regs);
+		VM86_FAULT_RETURN;
+
+	default:
+		return_to_32bit(regs, VM86_UNKNOWN);
+	}
+}
+
+/* ---------------- vm86 special IRQ passing stuff ----------------- */
+
+#define VM86_IRQNAME		"vm86irq"
+
+static struct vm86_irqs {
+	struct task_struct *tsk;
+	int sig;
+} vm86_irqs[16] = {{0},}; 
+static int irqbits=0;
+
+#define ALLOWED_SIGS ( 1 /* 0 = don't send a signal */ \
+	| (1 << SIGUSR1) | (1 << SIGUSR2) | (1 << SIGIO)  | (1 << SIGURG) \
+	| (1 << SIGUNUSED) )
+	
+static void irq_handler(int intno, void *dev_id, struct pt_regs * regs) {
+	int irq_bit;
+	unsigned long flags;
+	
+	save_flags(flags);
+	cli();
+	irq_bit = 1 << intno;
+	if ((irqbits & irq_bit) || ! vm86_irqs[intno].tsk) {
+		restore_flags(flags);
 		return;
 	}
+	irqbits |= irq_bit;
+	if (vm86_irqs[intno].sig)
+		send_sig(vm86_irqs[intno].sig, vm86_irqs[intno].tsk, 1);
+	/* else user will poll for IRQs */
+	restore_flags(flags);
+}
 
-	/*
-	 * We didn't recognize it, let the emulator take care of it..
-	 */
-	return_to_32bit(regs, VM86_UNKNOWN);
+static inline void free_vm86_irq(int irqnumber)
+{
+	free_irq(irqnumber,0);
+	vm86_irqs[irqnumber].tsk = 0;
+	irqbits &= ~(1 << irqnumber);
+}
+
+static inline int task_valid(struct task_struct *tsk)
+{
+	struct task_struct *p;
+
+	for_each_task(p) {
+		if ((p == tsk) && (p->sig)) return 1;
+	}
+	return 0;
+}
+
+static inline void handle_irq_zombies(void)
+{
+	int i;
+	for (i=3; i<16; i++) {
+		if (vm86_irqs[i].tsk) {
+			if (task_valid(vm86_irqs[i].tsk)) continue;
+			free_vm86_irq(i);
+		}
+	}
 }
+
+static inline int get_and_reset_irq(int irqnumber)
+{
+	int bit;
+	unsigned long flags;
+	
+	if ( (irqnumber<3) || (irqnumber>15) ) return 0;
+	if (vm86_irqs[irqnumber].tsk != current) return 0;
+	save_flags(flags);
+	cli();
+	bit = irqbits & (1 << irqnumber);
+	irqbits &= ~bit;
+	restore_flags(flags);
+	return bit;
+}
+
+
+static int do_vm86_irq_handling(int subfunction, int irqnumber)
+{
+	int ret;
+	switch (subfunction) {
+		case VM86_GET_AND_RESET_IRQ: {
+			return get_and_reset_irq(irqnumber);
+		}
+		case VM86_GET_IRQ_BITS: {
+			return irqbits;
+		}
+		case VM86_REQUEST_IRQ: {
+			int sig = irqnumber >> 8;
+			int irq = irqnumber & 255;
+			handle_irq_zombies();
+			if (!suser()) return -EPERM;
+			if (!((1 << sig) & ALLOWED_SIGS)) return -EPERM;
+			if ( (irq<3) || (irq>15) ) return -EPERM;
+			if (vm86_irqs[irq].tsk) return -EPERM;
+			ret = request_irq(irq, &irq_handler, 0, VM86_IRQNAME, 0);
+			if (ret) return ret;
+			vm86_irqs[irq].sig = sig;
+			vm86_irqs[irq].tsk = current;
+			return irq;
+		}
+		case  VM86_FREE_IRQ: {
+			handle_irq_zombies();
+			if ( (irqnumber<3) || (irqnumber>15) ) return -EPERM;
+			if (!vm86_irqs[irqnumber].tsk) return 0;
+			if (vm86_irqs[irqnumber].tsk != current) return -EPERM;
+			free_vm86_irq(irqnumber);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
diff -ur linux-2.1.8-clean/include/asm-i386/ldt.h linux/include/asm-i386/ldt.h
--- linux-2.1.8-clean/include/asm-i386/ldt.h	Wed Oct 16 21:34:09 1996
+++ linux/include/asm-i386/ldt.h	Sun Nov 10 21:43:33 1996
@@ -20,6 +20,7 @@
 	unsigned int  read_exec_only:1;
 	unsigned int  limit_in_pages:1;
 	unsigned int  seg_not_present:1;
+	unsigned int  useable:1;
 };
 
 #define MODIFY_LDT_CONTENTS_DATA	0
diff -ur linux-2.1.8-clean/include/asm-i386/vm86.h linux/include/asm-i386/vm86.h
--- linux-2.1.8-clean/include/asm-i386/vm86.h	Mon Nov 11 00:08:03 1996
+++ linux/include/asm-i386/vm86.h	Mon Nov 11 01:16:50 1996
@@ -43,6 +43,23 @@
 #define VM86_STI	3	/* sti/popf/iret instruction enabled virtual interrupts */
 
 /*
+ * Additional return values when invoking vm86() in vm86plus mode
+ */
+#define VM86_PICRETURN	4	/* return due to pending PIC request */
+#define VM86_TRAP	6	/* return due to DOS-debugger request */
+
+/*
+ * function codes when invoking vm86() in vm86plus mode
+ */
+#define VM86_PLUS_INSTALL_CHECK	((unsigned long)-255)
+#define VM86_ENTER		((unsigned long)-1)
+#define VM86_ENTER_NO_BYPASS	((unsigned long)-2)
+#define	VM86_REQUEST_IRQ	((unsigned long)-3)
+#define VM86_FREE_IRQ		((unsigned long)-4)
+#define VM86_GET_IRQ_BITS	((unsigned long)-5)
+#define VM86_GET_AND_RESET_IRQ	((unsigned long)-6)
+
+/*
  * This is the stack-layout when we have done a "SAVE_ALL" from vm86
  * mode - the main change is that the old segment descriptors aren't
  * useful any more and are forced to be zero by the kernel (and the
@@ -97,10 +114,27 @@
  */
 #define VM86_SCREEN_BITMAP	0x0001
 
+struct vm86plus_info_struct {
+        unsigned long force_return_for_pic:1;
+        unsigned long vm86dbg_active:1;       /* for debugger */
+        unsigned long vm86dbg_TFpendig:1;     /* for debugger */
+        unsigned char vm86dbg_intxxtab[32];   /* for debugger */
+};
+
+struct vm86plus_struct {
+	struct vm86_regs regs;
+	unsigned long flags;
+	unsigned long screen_bitmap;
+	unsigned long cpu_type;
+	struct revectored_struct int_revectored;
+	struct revectored_struct int21_revectored;
+	struct vm86plus_info_struct vm86plus;
+};
+
 #ifdef __KERNEL__
 
 void handle_vm86_fault(struct vm86_regs *, long);
-void handle_vm86_debug(struct vm86_regs *, long);
+int handle_vm86_trap(struct vm86_regs *, long, int);
 
 #endif
 
