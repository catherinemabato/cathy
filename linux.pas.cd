*** phantom.pas	Thu Nov 26 13:14:22 1992
--- linux.pas	Thu Nov 26 13:15:29 1992
***************
*** 7,13 ****
  
  program phantom_drive;
  uses
!     dos, crt;
  
  type
      sig_rec = record
--- 7,13 ----
  
  program phantom_drive;
  uses
!     dos;
  
  type
      sig_rec = record
***************
*** 22,28 ****
      our : sig_rec =
          (   signature : 'PHANTOM'; psp : 0; drive_no : 0);
      vollab : string[13] = 'AN ILLUS.ION'#0; { Our Volume label }
!     maxfilesize = 32767;                     { for our 1 file }
  
      isr_code_max = 102;                     { offset of last byte }
                                              { in our ISR macine code }
--- 22,28 ----
      our : sig_rec =
          (   signature : 'PHANTOM'; psp : 0; drive_no : 0);
      vollab : string[13] = 'AN ILLUS.ION'#0; { Our Volume label }
!     maxfilesize = 32;                     { for our 1 file }
  
      isr_code_max = 102;                     { offset of last byte }
                                              { in our ISR macine code }
***************
*** 290,295 ****
--- 290,296 ----
      file_attr : byte;
      file_size : longint;
  
+ 
  { Our full directory structure }
      max_path : ascbuf;
  
***************
*** 313,318 ****
--- 314,350 ----
      sda : pointer;          { pointer to the Swappable Dos Area }
      lol : pointer;          { pointer to the DOS list of lists struct }
  
+ {
+       1                                             .386
+       2     0000                         CodeSeg    SEGMENT USE16
+       3                                             ASSUME cs: CodeSeg
+       4     0000  0F B4 BE 03E8                     lfs     di,1000[bp]
+       5     0005  0F B5 B6 07D0                     lgs     si,2000[bp]
+       6     000A  8B 8E 0BB8                        mov     cx,3000[bp]
+       7     000E  8A 86 0FA0                        mov     al,4000[bp]
+       8     0012  BB 1234                           mov     bx,1234h
+       9     0015  B4 FA                             mov     ah, 0fah
+      10     0017  CD 21                             int     21h
+      11     0019  89 86 1388                        mov     5000[bp],ax
+      12     001D                         CodeSeg    ENDS
+      13                                             END
+ }
+ function linux(n : integer; p1, p2 : pointer; c: integer) : integer;
+ var res : integer;
+ begin
+     inline(
+         $f/$b4/$be/p1/
+         $f/$b5/$b6/p2/
+         $8b/$8e/c/
+         $8a/$86/n/
+         $bb/$34/$12/
+         $b4/$fa/
+         $cd/$21/
+         $89/$86/res
+     );
+     linux := res;
+ end;
+ 
  const h:array[0..15] of char = '0123456789abcdef';
  type str4 = string[4];
  function hex(inp:word):str4;
***************
*** 462,495 ****
  { Change Directory - subfunction 05h }
  procedure cd;
  var lsrc : byte;
  begin
      lsrc:=asclen(a1^);
      if lsrc=succ(iroot) then dec(lsrc); { Special case for root }
-     if not process_path(a1,lsrc) then exit;
      if dos_major=3 then             { Copy in the new path into the CDS }
!         move(max_path,cds3_rec(sda3_rec(sda^).drive_cdsptr^).curr_path,lsrc)
      else
!         move(max_path,cds4_rec(sda4_rec(sda^).drive_cdsptr^).curr_path,lsrc);
!     icur:=lsrc;
  end;
  
  { Remove Directory - subfunction 01h }
  procedure rd;
  var lsrc : byte;
  begin
      lsrc:=asclen(a1^);
!     if not process_path(a1,lsrc) then exit;
      if lsrc=icur then begin fail(5); exit; end;
      if lsrc=ifile then begin fail(5); exit; end;
      if lsrc<>lmax then begin fail(5); exit; end;
      if not back_1(max_path,lmax) then begin fail(3); exit; end;
      max_path[succ(lmax)]:=#0;
  end;
  
  { Make Directory - subfunction 03h }
  procedure md;
  var lsrc, isrc : byte;
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(5); exit; end;
--- 494,548 ----
  { Change Directory - subfunction 05h }
  procedure cd;
  var lsrc : byte;
+     i : integer;
+ begin
+     i := linux(1, a1, NIL, 0);
+     if i <> 0 then
        begin
+         fail(i);
+         exit;
+       end;
      lsrc:=asclen(a1^);
      if lsrc=succ(iroot) then dec(lsrc); { Special case for root }
      if dos_major=3 then             { Copy in the new path into the CDS }
!         move(a1^,cds3_rec(sda3_rec(sda^).drive_cdsptr^).curr_path,lsrc)
      else
!         move(a1^,cds4_rec(sda4_rec(sda^).drive_cdsptr^).curr_path,lsrc);
  end;
  
  { Remove Directory - subfunction 01h }
  procedure rd;
  var lsrc : byte;
+     i : integer;
+ begin
+     i := linux(3, a1, NIL, 0);
+     if i <> 0 then
        begin
+         fail(i);
+         exit;
+       end;
      lsrc:=asclen(a1^);
! {    if not process_path(a1,lsrc) then exit;
      if lsrc=icur then begin fail(5); exit; end;
      if lsrc=ifile then begin fail(5); exit; end;
      if lsrc<>lmax then begin fail(5); exit; end;
      if not back_1(max_path,lmax) then begin fail(3); exit; end;
      max_path[succ(lmax)]:=#0;
+     }
  end;
  
  { Make Directory - subfunction 03h }
  procedure md;
  var lsrc, isrc : byte;
+     i : integer;
  begin
+     i := linux(2, a1, NIL, 0);
+     if i <> 0 then
+       begin
+         fail(i);
+         exit;
+       end;
+       {
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(5); exit; end;
***************
*** 499,504 ****
--- 552,558 ----
      max_path[lsrc]:='\';
      max_path[succ(lsrc)]:=#0;
      lmax:=lsrc;
+     }
  end;
  
  { pop di   push cs   mov ax, 1208h   int 2fh }
***************
*** 509,514 ****
--- 563,569 ----
  
  { Close File - subfunction 06h }
  procedure clsfil;
+ var i : integer;
  begin
  { Clear down supplied SFT entry for file }
      with sft_rec(ptr(r.es,r.di)^) do
***************
*** 515,529 ****
--- 570,588 ----
          begin
              if dec_SFT(r.es,r.di)=1 then
                  begin
+                     i := linux(9, NIL, NIL, dir_sector);
+                     if i <> 0 then begin fail(i); exit; end;
                      handle_cnt:=0;
                      dir_sector:=0; { ??? MSCDEX does it.. }
                      devdrv_ptr:=nil; { ??? MSCDEX does it.. }
                  end;
+     (*
              if boolean(open_mode and 3) and
                 not boolean(dev_info and $40) then
                                  { if new or updated file... }
                      if f_time=0 then file_time:=the_time
                      else file_time:=f_time;
+     *)
          end;
  end;
  
***************
*** 535,540 ****
--- 594,603 ----
  
  { Read from File - subfunction 08h }
  procedure readfil;
+ var p : pointer;
+     i : integer;
+     pos : longint; {do not change pos and a}
+     a : integer;
  begin
  
  { Fill the user's buffer (the DTA) from our internal; file buffer,
***************
*** 542,553 ****
      with sft_rec(ptr(r.es,r.di)^) do
          begin
              { if (f_pos+r.cx)>f_size then r.cx:=f_size-f_pos; }
!             if f_pos >= f_size then r.cx := 0
              else if (f_pos + r.cx) > f_size then r.cx := f_size - f_pos;
              if dos_major=3 then
!                 move(file_buffer[f_pos],sda3_rec(sda^).curr_dta^,r.cx)
              else
!                 move(file_buffer[f_pos],sda4_rec(sda^).curr_dta^,r.cx);
              inc(f_pos,r.cx);
          end;
  end;
--- 605,622 ----
      with sft_rec(ptr(r.es,r.di)^) do
          begin
              { if (f_pos+r.cx)>f_size then r.cx:=f_size-f_pos; }
! {            if f_pos >= f_size then r.cx := 0
              else if (f_pos + r.cx) > f_size then r.cx := f_size - f_pos;
+ }
              if dos_major=3 then
!                 p := sda3_rec(sda^).curr_dta
              else
!                 p := sda4_rec(sda^).curr_dta;
!             a := r.cx;
!             pos := f_pos;
!             i := linux(10, p, @a, dir_sector);
!             r.cx := a;
!             if i <> 0 then begin fail(i); r.cx := 0; exit; end;
              inc(f_pos,r.cx);
          end;
  end;
***************
*** 554,559 ****
--- 623,632 ----
  
  { Write to File - subfunction 09h }
  procedure writfil;
+ var p : pointer;
+     i : integer;
+     pos : longint; {do not change pos and a}
+     a : integer;
  begin
  
  { Update our internal file buffer from the user buffer (the DTA) and
***************
*** 560,575 ****
    update the supplied SFT entry for the file }
      with sft_rec(ptr(r.es,r.di)^) do
          begin
!             if boolean(file_attr and readonly) then
                  begin fail(5); exit; end; 
              if (f_pos+r.cx)>maxfilesize then r.cx:=maxfilesize-f_pos;
              if dos_major=3 then
!                 move(sda3_rec(sda^).curr_dta^,file_buffer[f_pos],r.cx)
              else
!                 move(sda4_rec(sda^).curr_dta^,file_buffer[f_pos],r.cx);
              inc(f_pos,r.cx);
!             if f_pos>file_size then file_size:=f_pos;
!             f_size:=file_size;
              dev_info:=dev_info and (not $40);
          end;
  end;
--- 633,653 ----
    update the supplied SFT entry for the file }
      with sft_rec(ptr(r.es,r.di)^) do
          begin
! {            if boolean(file_attr and readonly) then
                  begin fail(5); exit; end;
              if (f_pos+r.cx)>maxfilesize then r.cx:=maxfilesize-f_pos;
+ }
              if dos_major=3 then
!                 p := sda3_rec(sda^).curr_dta
              else
!                 p := sda4_rec(sda^).curr_dta;
!             a := r.cx;
!             pos := f_pos;
!             i := linux(11, p, @a, dir_sector);
!             r.cx := a;
!             if i <> 0 then begin fail(i); r.cx := 0; exit; end;
              inc(f_pos,r.cx);
!             if f_pos>f_size then f_size:=f_pos;
              dev_info:=dev_info and (not $40);
          end;
  end;
***************
*** 576,594 ****
  
  { Get Disk Space - subfunction 0Ch }
  procedure dskspc;
  begin
  { Our 'disk' has 1 cluster containing 1 sector of maxfilesize bytes, and ... }
      r.ax:=1; 
      r.bx:=1;
!     r.cx:=succ(maxfilesize);
! { ... its either all available or none! }
!     r.dx:=ord(ifile=0);
  end;
  
  { Set File Attributes - subfunction 0Eh }
  procedure setfatt;
  var lsrc, isrc : byte;
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(2); exit; end;
--- 654,676 ----
  
  { Get Disk Space - subfunction 0Ch }
  procedure dskspc;
+ var i : integer;
  begin
  { Our 'disk' has 1 cluster containing 1 sector of maxfilesize bytes, and ... }
      r.ax:=1;
      r.bx:=1;
!     r.cx:=1024;
!     i := linux(15, @r.dx, NIL, 0);
  end;
  
  { Set File Attributes - subfunction 0Eh }
  procedure setfatt;
  var lsrc, isrc : byte;
+     i : integer;
  begin
+     i := linux(16, a1, NIL, byte(ptr(r.ss,r.sp)^));
+     if i <> 0 then begin fail(i); exit; end;
+     (*
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(2); exit; end;
***************
*** 600,611 ****
--- 682,698 ----
      if temp_name<>file_name then begin fail(2); exit; end;
  {    if file_opens>0 then fail(5)
      else }  file_attr:=byte(ptr(r.ss,r.sp)^);
+     *)
  end;
  
  { Get File Attributes - subfunction 0Fh }
  procedure getfatt;
  var lsrc, isrc : byte;
+     i : integer;
  begin
+     i := linux(17, a1, @r.ax, 0);
+     if i <> 0 then begin fail(i); exit; end;
+     (*
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(2); exit; end;
***************
*** 617,627 ****
      if temp_name<>file_name then begin fail(2); exit; end;
  {    if file_opens>0 then begin fail(5); exit; end; }
      r.ax:=file_attr;
  end;
  
  { Rename File - subfunction 11h }
  procedure renfil;
! var lsrc, isrc, isav, i : byte;
      dot:boolean;
  begin
      if dos_major=3 then
--- 704,715 ----
      if temp_name<>file_name then begin fail(2); exit; end;
  {    if file_opens>0 then begin fail(5); exit; end; }
      r.ax:=file_attr;
+     *)
  end;
  
  { Rename File - subfunction 11h }
  procedure renfil;
! var lsrc, isrc, isav, i : integer;
      dot:boolean;
  begin
      if dos_major=3 then
***************
*** 628,633 ****
--- 716,724 ----
          a2:=ptr(r.ss,sda3_rec(sda^).fn2_csofs)
      else
          a2:=ptr(r.ss,sda4_rec(sda^).fn2_csofs);
+     i := linux(14, a1, a2, 0);
+     if i <> 0 then begin fail(i); exit; end;
+     (*
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
***************
*** 649,656 ****
--- 740,780 ----
  { Put in the new file name }
      fillchar(file_name,13,#0);
      move(a2^[isrc],file_name,lsrc-isrc);
+     *)
  end;
  
+ var
+     lname : array[0..11] of char;
+     lsize : longint;
+     ldate,
+     ltime : word;
+     lattr : byte;
+ 
+ procedure matched(var m, t; var s : sdb_rec; var d : dir_rec;
+                 d_e, p_c : word; s_a : byte);
+ var i, j : byte;
+     mask : ascbuf absolute m;
+     tgt : ascbuf absolute t;
+ begin
+     with s do
+         begin
+             move(mask,srch_tmpl,11);
+             dir_entry:=d_e;
+             srch_attr:=s_a;
+             par_clstr:=p_c;
+             drv_lett:=drive_no or $80;
+         end;
+     with d do
+         begin
+             move(lname, fname, 11);
+             fattr := lattr;
+             time_lstupd:= ltime;
+             date_lstupd:= ldate;
+             fsiz:= lsize;
+         end;
+ end;
+ 
+ (*
  { This procedure does a wildcard match from the mask onto the target, and,
    if a hit, updates the search data block and found file areas supplied }
  function match(var m, t; var s : sdb_rec; var d : dir_rec;
***************
*** 704,709 ****
--- 828,834 ----
          end;
      match:=true;
  end;
+ *)
  
  { Delete File - subfunction 13h }
  procedure delfil;
***************
*** 710,716 ****
--- 835,845 ----
  var isrc, lsrc : byte;
      sdb:sdb_rec;    { These are dummies for the match procedure to hit }
      der:dir_rec;
+     i : integer;
  begin
+     i := linux(13, a1, NIL, 0);
+     if i <> 0 then begin fail(i); exit; end;
+     {
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
***************
*** 722,744 ****
      if ((file_attr and $1f)>0) then begin fail(5); exit; end;
      if not match(temp_name,file_name,sdb,der,0,0,0) then
          begin fail(2); exit; end;
!     { if file_opens=0 then } ifile:=0 { else fail(5) } ;
  end;
  
  { Open Existing File - subfunction 16h }
  procedure opnfil;
  var isrc, lsrc : byte;
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
      if not process_path(a1,isrc) then exit;
      if isrc<>ifile then begin fail(2); exit; end;
      inc(isrc);
      fillchar(temp_name,13,#0);
      move(a1^[isrc],temp_name,lsrc-isrc);
  { Check file names match }
      if temp_name<>file_name then begin fail(2); exit; end;
  
  { Initialize supplied SFT entry }
      with sft_rec(ptr(r.es,r.di)^) do
--- 851,883 ----
      if ((file_attr and $1f)>0) then begin fail(5); exit; end;
      if not match(temp_name,file_name,sdb,der,0,0,0) then
          begin fail(2); exit; end;
!     ifile:=0;
!     }
  end;
  
+ var
+     sz : longint; {do not change sz and f}
+     f : integer;
+ 
  { Open Existing File - subfunction 16h }
  procedure opnfil;
  var isrc, lsrc : byte;
+     i : integer;
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
+     {
      if not process_path(a1,isrc) then exit;
      if isrc<>ifile then begin fail(2); exit; end;
+     }
      inc(isrc);
      fillchar(temp_name,13,#0);
      move(a1^[isrc],temp_name,lsrc-isrc);
  { Check file names match }
+ {
      if temp_name<>file_name then begin fail(2); exit; end;
+ }
  
  { Initialize supplied SFT entry }
      with sft_rec(ptr(r.es,r.di)^) do
***************
*** 748,761 ****
                  open_mode:=sda3_rec(sda^).open_mode and $7f
              else
                  open_mode:=sda4_rec(sda^).open_mode and $7f;
              cnvt2fcb(temp_name,fcb_fn);
           {   inc(file_opens); }
!             f_size:=file_size;
!             f_time:=file_time;
              dev_info:=$8040 or drive_no; { Network drive, unwritten to }
!             dir_sector:=0;
              dir_entryno:=0;
!             attr_byte:=file_attr;
              f_pos:=0;
              devdrv_ptr:=nil;
              set_Owner(r.es,r.di);
--- 887,902 ----
                  open_mode:=sda3_rec(sda^).open_mode and $7f
              else
                  open_mode:=sda4_rec(sda^).open_mode and $7f;
+             i := linux(6, a1, @sz, open_mode);
+             if i <> 0 then begin fail(i); exit; end;
              cnvt2fcb(temp_name,fcb_fn);
           {   inc(file_opens); }
!             f_size:=sz;
!             f_time:=0;
              dev_info:=$8040 or drive_no; { Network drive, unwritten to }
!             dir_sector:=f;
              dir_entryno:=0;
!             attr_byte:=0;
              f_pos:=0;
              devdrv_ptr:=nil;
              set_Owner(r.es,r.di);
***************
*** 765,798 ****
  { Truncate/Create File - subfunction 17h }
  procedure creatfil;
  var isrc, lsrc : byte;
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
      if not process_path(a1,isrc) then exit;
  
!     if ifile=0 then 
!         begin
! { Creating new file }
!             ifile:=isrc;
              inc(isrc);
-             if isrc=lsrc then begin fail(13); ifile:=0; exit; end;
              fillchar(file_name,13,#0);
              move(a1^[isrc],file_name,lsrc-isrc);
-         end
-     else
- 
-     if ifile=isrc then
-         begin
- { Truncate existing file }
-             inc(isrc);
-             fillchar(temp_name,13,#0);
-             move(a1^[isrc],temp_name,lsrc-isrc);
-             if temp_name<>file_name then begin fail(2); exit; end;
-             if boolean(file_attr and $7) then begin fail(5); exit; end;
-           {  if file_opens>0 then begin fail(5); exit; end; }
-         end
-     else fail(82);  { This provokes a 'ran out of dir entries' error }
  
  { Initialize supplied SFT entry }
      with sft_rec(ptr(r.es,r.di)^) do
--- 906,925 ----
  { Truncate/Create File - subfunction 17h }
  procedure creatfil;
  var isrc, lsrc : byte;
+     i, f : integer;
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
+     {
      if not process_path(a1,isrc) then exit;
+     }
  
!     i := linux(7, a1, @f, $01);
!     if i <> 0 then begin fail(i); exit; end;
      inc(isrc);
      fillchar(file_name,13,#0);
      move(a1^[isrc],file_name,lsrc-isrc);
  
  { Initialize supplied SFT entry }
      with sft_rec(ptr(r.es,r.di)^) do
***************
*** 805,815 ****
              f_pos:=0;
              file_size:=0;
              dev_info:=$8040 or drive_no; { Network drive, unwritten to }
!             dir_sector:=0;
              dir_entryno:=0;
              f_time:=0;
              devdrv_ptr:=nil;
!             attr_byte:=file_attr;
              set_Owner(r.es,r.di);
          end;
  end;
--- 932,942 ----
              f_pos:=0;
              file_size:=0;
              dev_info:=$8040 or drive_no; { Network drive, unwritten to }
!             dir_sector:=f;
              dir_entryno:=0;
              f_time:=0;
              devdrv_ptr:=nil;
!             attr_byte:=0;
              set_Owner(r.es,r.di);
          end;
  end;
***************
*** 817,881 ****
  { Special Multi-Purpose Open File - subfunction 2Eh }
  procedure spopnfil;
  var isrc, lsrc : byte;
!     action, mode, result : word;
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
!     if not process_path(a1,isrc) then exit;
      mode:=sda4_rec(sda^).spop_mode and $7f;
      action:=sda4_rec(sda^).spop_act;
! { First, check if file must or must not exist }
!     if ((((action and $f)=0) and (isrc<>0)) or
!         (((action and $f0)=0) and (isrc=0))) then begin fail(5); exit; end;
  
-     if ifile=0 then 
-         begin
- { Creating new file }
-             result:=2;
-             ifile:=isrc;
              inc(isrc);
!             if isrc=lsrc then begin fail(13); ifile:=0; exit; end;
              fillchar(file_name,13,#0);
              move(a1^[isrc],file_name,lsrc-isrc);
-         end
-     else
- 
-     if ifile=isrc then
-         begin
- { Open/Truncate existing file }
-             inc(isrc);
-             fillchar(temp_name,13,#0);
-             move(a1^[isrc],temp_name,lsrc-isrc);
-             if temp_name<>file_name then begin fail(82); exit; end;
-             if boolean(action and 2) then
-                 result:=3           { File existed, was replaced }
-             else
-                 result:=1;          { File existed, was opened }
-             if boolean(file_attr and $1) and
-                 ((result=3) or ((mode and 3)>0)) then
-                 begin fail(5); exit; end;   { It's a read only file }
-             if (result=3) { and (file_opens>0) } then
-                 begin fail(5); exit; end;   { Truncating an open file }
-         end
-     else fail(5);
  
  { Initialize the supplied SFT entry }
      with sft_rec(ptr(r.es,r.di)^) do
          begin
!             if result>1 then
                  begin
                      file_attr:=byte(ptr(r.ss,r.sp)^); { Attr is top of stack }
                      f_size:=0;
-                     file_size:=0;
                  end;
              open_mode:=mode;
              cnvt2fcb(file_name,fcb_fn);
-             { inc(file_opens); }
              f_pos:=0;
              f_time:=0;
              dev_info:=$8040 or drive_no; { Network drive, unwritten to }
!             dir_sector:=0;
              dir_entryno:=0;
              devdrv_ptr:=nil;
              attr_byte:=file_attr;
--- 944,983 ----
  { Special Multi-Purpose Open File - subfunction 2Eh }
  procedure spopnfil;
  var isrc, lsrc : byte;
!     action, mode : word;
!     i : integer;
!     f : integer;
!     sz : longint; {do not change sz and f}
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
!     { if not process_path(a1,isrc) then exit; }
      mode:=sda4_rec(sda^).spop_mode and $7f;
      action:=sda4_rec(sda^).spop_act;
!     i := linux(8, a1, @sz, (action shl 8) or mode);
!     if i <> 0 then begin fail(i); exit; end;
  
      inc(isrc);
!     if isrc=lsrc then begin fail(13); exit; end;
      fillchar(file_name,13,#0);
      move(a1^[isrc],file_name,lsrc-isrc);
  
  { Initialize the supplied SFT entry }
      with sft_rec(ptr(r.es,r.di)^) do
          begin
!             if sz < 0 then
                  begin
                      file_attr:=byte(ptr(r.ss,r.sp)^); { Attr is top of stack }
                      f_size:=0;
                  end;
              open_mode:=mode;
              cnvt2fcb(file_name,fcb_fn);
              f_pos:=0;
              f_time:=0;
+             f_size:=sz;
              dev_info:=$8040 or drive_no; { Network drive, unwritten to }
!             dir_sector:=f;
              dir_entryno:=0;
              devdrv_ptr:=nil;
              attr_byte:=file_attr;
***************
*** 889,903 ****
      sdb : sdb_ptr;
      der : dir_ptr;
      sa, fa : byte;
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
      if not process_path(a1,isrc) then exit;
!     a2:=@max_path;
      if dos_major=3 then
          begin
!             a1:=@sda3_rec(sda^).fcb_fn1;
              sdb:=@sda3_rec(sda^).sdb;
              der:=@sda3_rec(sda^).found_file;
              sa:=sda3_rec(sda^).srch_attr;
--- 991,1007 ----
      sdb : sdb_ptr;
      der : dir_ptr;
      sa, fa : byte;
+     i : integer;
  begin
      lsrc:=asclen(a1^);
      isrc:=lsrc;
+     {
      if not back_1(a1^,isrc) then begin fail(3); exit; end;
      if not process_path(a1,isrc) then exit;
!     }
      if dos_major=3 then
          begin
!             a2:=@sda3_rec(sda^).fcb_fn1;
              sdb:=@sda3_rec(sda^).sdb;
              der:=@sda3_rec(sda^).found_file;
              sa:=sda3_rec(sda^).srch_attr;
***************
*** 904,914 ****
          end
      else
          begin
!             a1:=@sda4_rec(sda^).fcb_fn1;
              sdb:=@sda4_rec(sda^).sdb;
              der:=@sda4_rec(sda^).found_file;
              sa:=sda4_rec(sda^).srch_attr;
          end;
      fa:=file_attr and $1e;
      inc(os(a2).o,succ(isrc));
  
--- 1008,1026 ----
          end
      else
          begin
!             a2:=@sda4_rec(sda^).fcb_fn1;
              sdb:=@sda4_rec(sda^).sdb;
              der:=@sda4_rec(sda^).found_file;
              sa:=sda4_rec(sda^).srch_attr;
          end;
+     i := linux(4, a1, @lname, sa);
+     if i <> 0 then begin fail(i); exit end;
+     matched(a2^,vollab[1],sdb^,der^,0,isrc,sa);
+ (*
+     exit;
+ 
+     a1 := a2;
+     a2:=@max_path;
      fa:=file_attr and $1e;
      inc(os(a2).o,succ(isrc));
  
***************
*** 928,933 ****
--- 1040,1046 ----
  
  { Otherwise report no more files }
      fail(18);
+ *)
  end;
  
  { FindFirst - subfunction 1Bh }
***************
*** 934,939 ****
--- 1047,1053 ----
  procedure fnext;
  var fa : byte;
      sdb : sdb_ptr; der : dir_ptr;
+     i : integer;
  begin
      if dos_major=3 then
          begin
***************
*** 945,950 ****
--- 1059,1071 ----
              sdb:=@sda4_rec(sda^).sdb;
              der:=@sda4_rec(sda^).found_file;
          end;
+     i := linux(5, NIL, @lname, sdb^.srch_attr);
+     if i <> 0 then begin fail(i); exit end;
+     matched(a2^,vollab[1],sdb^,der^,
+             sdb^.dir_entry,sdb^.par_clstr,sdb^.srch_attr);
+ (*
+     exit;
+ 
      fa:=file_attr and $1e;
      inc(sdb^.dir_entry);
      case sdb^.dir_entry of
***************
*** 969,987 ****
  
  { Otherwise return no more files }
      fail(18);
  end;
  
  { Seek From End Of File - subfunction 21h }
  procedure skfmend;
  var skamnt : longint;
  begin
!     skamnt:=(longint(r.cx)*65536)+r.dx;
      { if file_opens=0 then begin fail(5); exit; end; }
  
  { Update supplied SFT entry for file }
      with sft_rec(ptr(r.es,r.di)^) do
          begin
!             f_pos:=f_size-skamnt;
              r.dx:=f_pos shr 16;
              r.ax:=f_pos and $ffff;
          end;
--- 1090,1112 ----
  
  { Otherwise return no more files }
      fail(18);
+ *)
  end;
  
  { Seek From End Of File - subfunction 21h }
  procedure skfmend;
  var skamnt : longint;
+     i : integer;
  begin
!     skamnt:=-(longint(r.cx)*65536)-r.dx;
      { if file_opens=0 then begin fail(5); exit; end; }
  
  { Update supplied SFT entry for file }
      with sft_rec(ptr(r.es,r.di)^) do
          begin
!             i := linux(12, @skamnt, NIL, dir_sector);
!             if i <> 0 then begin fail(i); exit; end;
!             f_pos:=skamnt;
              r.dx:=f_pos shr 16;
              r.ax:=f_pos and $ffff;
          end;
