diff -ru linux/arch/i386/kernel/ldt.c linux.new/arch/i386/kernel/ldt.c
--- linux/arch/i386/kernel/ldt.c	Sun Feb  5 22:39:17 1995
+++ linux.new/arch/i386/kernel/ldt.c	Tue Mar 14 10:18:28 1995
@@ -49,16 +49,18 @@
 
 	memcpy_fromfs(&ldt_info, ptr, sizeof(ldt_info));
 
-	if (ldt_info.contents == 3 || ldt_info.entry_number >= LDT_ENTRIES)
+	if ((ldt_info.contents == 3 && ldt_info.seg_not_present == 0) || ldt_info.entry_number >= LDT_ENTRIES)
 		return -EINVAL;
 
 	limit = ldt_info.limit;
 	base = ldt_info.base_addr;
-	if (ldt_info.limit_in_pages)
+	if (ldt_info.limit_in_pages) {
 		limit *= PAGE_SIZE;
+		limit += PAGE_SIZE-1;
+	}
 
 	limit += base;
-	if (limit < base || limit >= 0xC0000000)
+	if ((limit < base || limit >= 0xC0000000) && ldt_info.seg_not_present == 0)
 		return -EINVAL;
 
 	if (!current->ldt) {
@@ -75,7 +77,10 @@
 	
 	lp = (unsigned long *) &current->ldt[ldt_info.entry_number];
    	/* Allow LDTs to be cleared by the user. */
-   	if (ldt_info.base_addr == 0 && ldt_info.limit == 0) {
+   	if (ldt_info.base_addr == 0 && ldt_info.limit == 0 &&
+	    ldt_info.contents == 0 && ldt_info.read_exec_only == 1 &&
+	    ldt_info.seg_32bit == 0 && ldt_info.limit_in_pages == 0 &&
+	    ldt_info.seg_not_present == 1 && ldt_info.useable == 0) {
 		*lp = 0;
 		*(lp+1) = 0;
 		return 0;
@@ -90,6 +95,7 @@
 		  (ldt_info.seg_32bit << 22) |
 		  (ldt_info.limit_in_pages << 23) |
 		  ((ldt_info.seg_not_present ^1) << 15) |
+		  (ldt_info.useable << 20) |
 		  0x7000;
 	return 0;
 }
diff -ru linux/include/linux/ldt.h linux.new/include/linux/ldt.h
--- linux/include/linux/ldt.h	Fri Jun 17 07:34:41 1994
+++ linux.new/include/linux/ldt.h	Thu Mar  9 12:48:01 1995
@@ -20,6 +20,7 @@
 	unsigned int  read_exec_only:1;
 	unsigned int  limit_in_pages:1;
 	unsigned int  seg_not_present:1;
+	unsigned int  useable:1;
 };
 
 #define MODIFY_LDT_CONTENTS_DATA	0
@@ -29,6 +30,6 @@
 extern int get_ldt(void *buffer);
 extern int set_ldt_entry(int entry, unsigned long base, unsigned int limit,
 			 int seg_32bit_flag, int contents, int read_only_flag,
-			 int limit_in_pages_flag);
+			 int limit_in_pages_flag, int seg_not_present_flag, int useable);
 
 #endif
diff -ru linux/arch/i386/kernel/signal.c linux.new/arch/i386/kernel/signal.c
--- linux/arch/i386/kernel/signal.c.pl12	Tue Mar 14 03:13:34 1995
+++ linux/arch/i386/kernel/signal.c	Tue Mar 14 04:08:31 1995
@@ -47,7 +47,7 @@
 {
 #define COPY(x) regs->x = context.x
 #define COPY_SEG(x) \
-if ((context.x & 0xfffc) && (context.x & 3) != 3) goto badframe; COPY(x);
+if ((context.x & 0xfffc) && (context.x & 0x4) != 0x4 && (context.x & 3) != 3) goto badframe; COPY(x);
 #define COPY_SEG_STRICT(x) \
 if (!(context.x & 0xfffc) || (context.x & 3) != 3) goto badframe; COPY(x);
 	struct sigcontext_struct context;


