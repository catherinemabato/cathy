diff -c --recursive linux.1.1.37/fs/proc/base.c linux/fs/proc/base.c
*** linux.1.1.37/fs/proc/base.c	Sun Jul 24 09:50:35 1994
--- linux/fs/proc/base.c	Sun Jul 31 21:46:14 1994
***************
*** 114,119 ****
--- 114,122 ----
  	if (base_dir[i].low_ino == 1)
  		ino = 1;
  	else
+         if (base_dir[i].low_ino == 3 && current->pid == pid)
+ 		ino = (pid << 16) + 16;
+ 	else
  		ino = (pid << 16) + base_dir[i].low_ino;
  	for (i = 0 ; i < NR_TASKS ; i++)
  		if (task[i] && task[i]->pid == pid)
diff -c --recursive linux.1.1.37/fs/proc/inode.c linux/fs/proc/inode.c
*** linux.1.1.37/fs/proc/inode.c	Mon May  2 10:34:29 1994
--- linux/fs/proc/inode.c	Sun Jul 31 21:46:14 1994
***************
*** 165,170 ****
--- 165,174 ----
  			inode->i_mode = S_IFREG | S_IRUGO;
  			inode->i_op = &proc_array_inode_operations;
  			return;
+ 		case 16:
+  			inode->i_op = &proc_selfmem_inode_operations;
+ 			inode->i_mode = S_IFREG | S_IRUSR | S_IWUSR;
+ 			return;
  	}
  	switch (ino >> 8) {
  		case 1:
diff -c --recursive linux.1.1.37/fs/proc/mem.c linux/fs/proc/mem.c
*** linux.1.1.37/fs/proc/mem.c	Wed Dec  1 06:44:15 1993
--- linux/fs/proc/mem.c	Sun Jul 31 22:31:22 1994
***************
*** 8,13 ****
--- 8,17 ----
  #include <linux/errno.h>
  #include <linux/sched.h>
  #include <linux/kernel.h>
+ #include <linux/malloc.h>
+ #include <linux/mm.h>
+ #include <linux/page.h>
+ #include <linux/mman.h>
  
  #include <asm/segment.h>
  #include <asm/io.h>
***************
*** 138,143 ****
--- 142,220 ----
  	}
  }
  
+ /*
+  * There is some danger using this with shared memory.  You can
+  * mmap to a shared region and it will work fine.  When you shmdt
+  * the region, the mmap will not be deleted, however.  In fact,
+  * you will be able to access the data even when nattach is 0.
+  * The danger may come if you then reattach the shared memory
+  * because then you're liable to pick up the NEW shared data.
+  * Is that confusing?  Good.  You shouldn't be doing it in the
+  * first place!  (This is not to say don't map shared data.  By
+  * all means, knock yourself out.  Just don't muck about with the
+  * mmap'ed area after you free the shared region.)
+  * Scott Buchholz, scottb@eecs.nwu.edu, 5/23/94
+  */
+ 
+ int
+ selfmem_mmap(struct inode * inode, struct file * file,
+ 	     struct vm_area_struct * vma)
+ {
+   unsigned long *src_table, *dest_table;
+   unsigned long stmp, dtmp;
+   struct vm_area_struct *src_vma;
+   int error;
+   
+   error = verify_area((vma->vm_flags & VM_WRITE) ? VERIFY_WRITE : VERIFY_READ,
+ 		      (void *)vma->vm_offset, vma->vm_end - vma->vm_start);
+   if (error)
+     return error;
+ 
+   src_vma = current->mm->mmap;
+   while (src_vma && src_vma->vm_end < vma->vm_offset)
+     src_vma = src_vma->vm_next;
+ 
+   for (stmp=vma->vm_offset, dtmp=vma->vm_start;  dtmp < vma->vm_end;
+        stmp += PAGE_SIZE, dtmp += PAGE_SIZE) { 
+ 
+     while (src_vma && stmp > src_vma->vm_end)
+       src_vma = src_vma->vm_next;
+ 
+     src_table = PAGE_DIR_OFFSET(current->tss.cr3, stmp);
+     if (!*src_table) goto bad_source;
+ 
+     src_table = (unsigned long *)((*src_table & PAGE_MASK) + PAGE_PTR(stmp));
+     if (!*src_table) goto bad_source;
+ 
+     dest_table = PAGE_DIR_OFFSET(current->tss.cr3, dtmp);
+ 
+     if (!*dest_table) {
+       *dest_table = get_free_page(GFP_KERNEL);
+       if (!*dest_table) { oom(current); *dest_table=BAD_PAGE; }
+       else *dest_table |= PAGE_TABLE;
+     }
+     
+     dest_table = (unsigned long *)((*dest_table & PAGE_MASK) + PAGE_PTR(dtmp));
+ 
+     if (!(*src_table & PAGE_PRESENT)) 
+       do_no_page(src_vma, stmp, PAGE_PRESENT);
+ 
+     if ((vma->vm_flags & VM_WRITE) && !(*src_table & PAGE_RW))
+       do_wp_page(src_vma, stmp, PAGE_RW | PAGE_PRESENT);
+ 
+     *src_table |= PAGE_DIRTY;
+     *dest_table = *src_table;
+     mem_map[MAP_NR(*src_table)]++;
+   }
+ 
+   invalidate();
+   return 0;
+ 
+ bad_source:
+   unmap_page_range(vma->vm_offset, vma->vm_end - vma->vm_start);
+   return (unsigned long) -EINVAL;
+ }
+ 
  static struct file_operations proc_mem_operations = {
  	mem_lseek,
  	mem_read,
***************
*** 153,158 ****
--- 230,266 ----
  
  struct inode_operations proc_mem_inode_operations = {
  	&proc_mem_operations,	/* default base directory file-ops */
+ 	NULL,			/* create */
+ 	NULL,			/* lookup */
+ 	NULL,			/* link */
+ 	NULL,			/* unlink */
+ 	NULL,			/* symlink */
+ 	NULL,			/* mkdir */
+ 	NULL,			/* rmdir */
+ 	NULL,			/* mknod */
+ 	NULL,			/* rename */
+ 	NULL,			/* readlink */
+ 	NULL,			/* follow_link */
+ 	NULL,			/* bmap */
+ 	NULL,			/* truncate */
+ 	NULL			/* permission */
+ };
+ 
+ static struct file_operations proc_selfmem_operations = {
+ 	mem_lseek,
+ 	mem_read,
+ 	mem_write,
+ 	NULL,		/* mem_readdir */
+ 	NULL,		/* mem_select */
+ 	NULL,		/* mem_ioctl */
+ 	selfmem_mmap,	/* mmap */
+ 	NULL,		/* no special open code */
+ 	NULL,		/* no special release code */
+ 	NULL		/* can't fsync */
+ };
+ 
+ struct inode_operations proc_selfmem_inode_operations = {
+ 	&proc_selfmem_operations, /* default base directory file-ops */
  	NULL,			/* create */
  	NULL,			/* lookup */
  	NULL,			/* link */
diff -c --recursive linux.1.1.37/include/linux/proc_fs.h linux/include/linux/proc_fs.h
*** linux.1.1.37/include/linux/proc_fs.h	Wed Dec  1 06:44:15 1993
--- linux/include/linux/proc_fs.h	Sun Jul 31 21:46:13 1994
***************
*** 27,32 ****
--- 27,33 ----
  extern struct inode_operations proc_base_inode_operations;
  extern struct inode_operations proc_net_inode_operations;
  extern struct inode_operations proc_mem_inode_operations;
+ extern struct inode_operations proc_selfmem_inode_operations;
  extern struct inode_operations proc_array_inode_operations;
  extern struct inode_operations proc_kmsg_inode_operations;
  extern struct inode_operations proc_link_inode_operations;
diff -c --recursive linux.1.1.37/mm/swap.c linux/mm/swap.c
*** linux.1.1.37/mm/swap.c	Sun Jul 31 11:40:49 1994
--- linux/mm/swap.c	Sun Jul 31 21:46:11 1994
***************
*** 299,305 ****
  		return 0;
  	if (page >= high_memory)
  		return 0;
! 	if (mem_map[MAP_NR(page)] & MAP_PAGE_RESERVED)
  		return 0;
  	
  	if ((PAGE_DIRTY & page) && delete_from_swap_cache(page))  {
--- 299,306 ----
  		return 0;
  	if (page >= high_memory)
  		return 0;
! 	if ((mem_map[MAP_NR(page)] & MAP_PAGE_RESERVED) ||
! 	    (mem_map[MAP_NR(page)] > 1))
  		return 0;
  	
  	if ((PAGE_DIRTY & page) && delete_from_swap_cache(page))  {
