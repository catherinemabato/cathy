Greetings DOSEMU fans,

Well, I suspect that I am about to be attacked with truckloads of bricks.
Yes, I have, in fact, changed the Hogthreshold code.

Why?  Basically because 'garrot', that cute little utility sitting in your
garrot02 directory does a fine job of doing it with much less effort than
the ungainly timer-based hogthreshold code.

So, the hogtreshold value has now become the same as the garrot value.
This means that good values start hovering around 10 (apparently they
should be "about half of your BogoMips value" -- see the garrot docs.)
Setting the hogthreshold to 0, as before, disables the idling code.

DOSEMU idles impressively using the new code.  On my 486-75 portable (no
cache), I notice no performance difference between Hogthreshold 0 & 10,
whereas the idle usage drops from 99.7% to 0.5%.

P.S.  If some brave soul is up for it, to change the HogThreshold value
during execution, simply call int e6h w/al=12h & bx=the new value.
Hint.  Hint.

Notes:  If your application is unkind enough to do waits using an int16h
fcn 1h loop without calling the keyboard idle interrupt (int 28h), this
code is not going to help much.  If someone runs into a program like this,
let me (scottb@eecs.nwu.edu) know and I'll rewrite something into the
int16 bios.

----------------------------------------------------------------------

This files is some kind of FAQ on how to use the 'HogThreshold' value in the
dosemu config file.

In case you have more questions feel free to ask me
( andi@andiunx.m.isar.de ).

Those of you who simply want to have DOSEMU running at highest possible speed
simply leave the value to zero, but if you are concerned about
DOSEMU eating too much CPU time it's worth playing with the HogThreshold value.


Q.:
Why do I need to set the HogThreshold value, why can't DOSEMU
     just stop if it is waiting for a keystroke ?

A.:
The reason is the way how DOS and a lot of applications have implemented
'waiting for a keystroke'.

It's most often done by something similar to the following code fragment :

wait_for_key:
	; do something
	mov ah,1
	int 0x16 ; check key status
	jz	wait_for_key ; jump if no key
	; found a key
        mov ah,0
        int 0x16 ; get key

This means that the application is busy waiting for the keystroke.


Q.:
What is a good value for HogThreshold to start with ?

A.:
On a 40 MHZ 486 start with a value of 10.
Increase this value if you to have your DOS application run faster,
decrease it if you think too much CPU time is used.

Q.:
It does not work on my machine.

A.:
You need to have at least dosemu0.53pl40 in order to have the
anti-hog code in effect.


Q.:
Why not simply use a very low value of "HogThreshold" ?
Do I really have to try an individual value of HogThreshold ?

A.:
This would slow down your DOS application. But why not, DOS is slow
anyway :-).


Q.:
How do I found out about CPU usage of DOSEMU ?

A.:
Simply use 'top'. It displays cpu and memory usage.
