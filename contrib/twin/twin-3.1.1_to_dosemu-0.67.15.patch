diff -urN twin-3.1.1/include/Log.h twin/include/Log.h
--- twin-3.1.1/include/Log.h	Fri Oct 24 16:46:22 1997
+++ twin/include/Log.h	Sat Nov  1 21:21:52 1997
@@ -1,18 +1,35 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*  Log.h	2.11
     Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
diff -urN twin-3.1.1/include/Win_Clib.h twin/include/Win_Clib.h
--- twin-3.1.1/include/Win_Clib.h	Fri Oct 24 16:46:22 1997
+++ twin/include/Win_Clib.h	Sat Nov  1 21:24:42 1997
@@ -1,18 +1,35 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*   Win_Clib.h	1.29
     Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
diff -urN twin-3.1.1/include/Win_Reg.h twin/include/Win_Reg.h
--- twin-3.1.1/include/Win_Reg.h	Fri Oct 24 16:46:22 1997
+++ twin/include/Win_Reg.h	Sat Nov  1 21:14:14 1997
@@ -1,18 +1,35 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*  Win_Reg.h	1.6
     Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -36,7 +53,7 @@
 
 #endif /* TWIN32 */
 
-#if 1
+#ifndef DOSEMU
 /*
 ** Windows 95 version of Win_Reg.h contains
 ** much of what we have presently in shellapi.h
diff -urN twin-3.1.1/include/kerndef.h twin/include/kerndef.h
--- twin-3.1.1/include/kerndef.h	Fri Oct 24 16:46:22 1997
+++ twin/include/kerndef.h	Sat Nov  1 21:25:45 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*************************************************************************
 	@(#)kerndef.h	2.30
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -39,6 +56,8 @@
 #define	EQUALS	==
 #define	NEQ	!=
 
+#ifndef DOSEMU
+
 /* Window field offsets for GetWindowLong() and GetWindowWord() */
 #ifndef	TWIN32
 #define GWW_HWNDFOCUS   (-36)
@@ -334,6 +353,8 @@
 /* 32-bit internal menu handle */
 DECLARE_HANDLE32(HMENU32);
 HGLOBAL GlobalHandle32(LPCVOID);
+
+#endif	/* DOSEMU */
 
 /* generic function pointer for conversion routines */
 typedef DWORD (* LONGPROC)();
diff -urN twin-3.1.1/include/platform.h twin/include/platform.h
--- twin-3.1.1/include/platform.h	Fri Oct 24 16:46:22 1997
+++ twin/include/platform.h	Sat Nov  1 21:26:35 1997
@@ -1,18 +1,35 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*  platform.h	1.25
     Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
diff -urN twin-3.1.1/include/windows.h twin/include/windows.h
--- twin-3.1.1/include/windows.h	Fri Oct 24 16:46:22 1997
+++ twin/include/windows.h	Sat Nov  1 21:27:16 1997
@@ -1,18 +1,35 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*  windows.h -   SDK Structure definitions, and API's.
     Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -227,7 +244,9 @@
 typedef FLOAT NEAR	*NPFLOAT;
 typedef FLOAT FAR	*LPFLOAT;
 
+#ifndef DOSEMU
 typedef unsigned char 	boolean;
+#endif
 typedef unsigned char 	byte;
 
 #ifdef  TWIN32
@@ -459,6 +478,7 @@
 #define _MAX_EXT    256
 #endif
 
+#ifndef DOSEMU
 #ifndef RC_INVOKED
 #include "Win_NT.h"
 #include "Win_Base.h"
@@ -489,6 +509,7 @@
 #define WM_SPOOLERSTATUS        0x002A
 
 #include "Win_MS.h"     /* Include any of the MS types we do not use */
+#endif	/* DOSEMU */
 
 #ifdef __cplusplus
 } /* Leave 'extern "C"' mode when switching header files */
@@ -502,12 +523,15 @@
 extern "C" {
 #endif
 
+#ifndef DOSEMU
 #include "dlgs.h"
+#endif	/* DOSEMU */
 
 #ifndef RC_INVOKED
 
 #include "Win_Reg.h"
 
+#ifndef DOSEMU
 #ifndef NO_WINSOCK
 #include "winsock.h"
 #endif
@@ -529,6 +553,7 @@
 #if defined(TWIN32)
 #include "print.h"
 #endif /* TWIN32 */
+#endif /* DOSEMU */
 #endif /* RC_INVOKED */
 
 #ifdef __cplusplus
diff -urN twin-3.1.1/intp32/COPYING.LIB twin/intp32/COPYING.LIB
--- twin-3.1.1/intp32/COPYING.LIB	Fri Oct 24 16:46:22 1997
+++ twin/intp32/COPYING.LIB	Mon Nov  3 01:03:21 1997
@@ -1,3 +1,26 @@
+------------------------------------------------------------------------------
+NOTE:
+Some code of the Twin package was modified for DOSEMU by the DOSEMU-team.
+The original is 'Copyright 1997 Willows Software, Inc.' and generously
+was put under the GNU Library General Public License.
+( for more information see http://www.willows.com/ )
+
+We make use of section 3 of the GNU Library General Public License
+('...opt to apply the terms of the ordinary GNU General Public License...'),
+because the resulting product is an integrated part of DOSEMU and
+can not be considered to be a 'library' in the terms of Library License.
+
+Therefore, the below GNU LIBRARY GENERAL PUBLIC LICENSE applies only to the
+_unchanged_ Twin package from Willows. For the DOSEMU-changed parts the normal
+GNU GENERAL PUBLIC LICENSE applies. This GPL (file COPYING) can be found in
+the root directory of the DOSEMU distribution.
+
+The act of transformation to GPL was indicated to the maintainer of the Twin
+package (Rob Penrose <rob@Canopy.Com>) and he acknowledge agreement.
+
+Nov. 1 1997, The DOSEMU team.
+
+------------------------------------------------------------------------------
 		  GNU LIBRARY GENERAL PUBLIC LICENSE
 		       Version 2, June 1991
 
diff -urN twin-3.1.1/intp32/Makefile twin/intp32/Makefile
--- twin-3.1.1/intp32/Makefile	Fri Oct 24 16:46:22 1997
+++ twin/intp32/Makefile	Fri Oct 24 16:36:26 1997
@@ -6,50 +6,64 @@
 #
 #	makefile for building 16/32 bit interpreter intp32 
 #
+#	changes for use with dosemu-0.67 1997/10/20 vignani@mbox.vol.it
+#
 ##########################################################################   
 
-include $(TWINDIR)/Makefile.config
-TWIN_AUXINC	= -I$(TWINDIR)/win
+# Bootstrap the makefile CONFIGURATION variables
+#
+# TWINDIR		where is the source tree
+# TARGET		what OS are we running on 
+# TWINCPU		what CPU are we running on
 
-##########################################################################   
+TWINDIR=.
+TARGET=linux
 
-SOURCE	=	fp87.c interp_main.c interp_modrm.c interp_16_32.c \
-		interp_32_16.c interp_32_32.c
+TWINCPU=X386
+
+#
+# TWIN_APISIZE=   implies 16bit library
+#             =32 implies 32bit library:w!
+#
+#
+TWIN_APISIZE=
+
+############################################
+#
+# Makeinclude.config
+#
+############################################
 
-OBJECTS  =	fp87.o interp_main.o interp_modrm.o interp_16_32.o \
-		interp_32_16.o interp_32_32.o
+TWIN_SYSINC=-I../include
+TWIN_WININC=-I../win
+
+CPUTYPE = CPU
+
+TWIN_CFLAGS   = -DX386 -Dlinux -DDOSEMU -DDEBUG -O6
+
+TWIN_IFLAGS   = $(TWIN_WININC) $(TWIN_AUXINC) $(TWIN_SYSINC)
+TWIN_BFLAGS   = $(TWIN_XFLAGS)
+TWIN_CFLAGS  += $(TWIN_IFLAGS) $(TWIN_BFLAGS)
+
+CFLAGS   += -fwritable-strings $(TWIN_CFLAGS)
 
 ##########################################################################   
 
-all: intp32.o libintp32.a
+CFILES	=	fp87.c interp_main.c interp_modrm.c interp_16_32.c \
+		interp_32_16.c interp_32_32.c
 
-intp32.o: $(OBJECTS)
-	$(LD) -r -o intp32.o $(OBJECTS)
-	cp intp32.o $(TWINDIR)/win
+##########################################################################   
 
-libintp32.a:	$(OBJECTS)
-		${AR} libintp32.a $?
-		$(RANLIB) libintp32.a
+SFILES=
+ALL=$(CFILES) $(SFILES)
 
-clobber: clean
+OBJS=$(CFILES:.c=.o)
+DEPENDS=$(CFILES:.c=.d)
 
-clean:
-		rm -f $(OBJECTS)
-		rm -f libintp32.a
+SUBDIR=twin
 
-source:
-	supdate .
+include $(REALTOPDIR)/src/Makefile.common
 
-depend:
-	makedepend -f Makedepend.$(TARGET) $(DEPEND) -I. $(CFLAGS)
+all: lib
 
-##########################################################################
-#
-# Source file dependencies are located in Makedepend.$(TARGET)
-#
-include Makedepend.$(TARGET)
 
-##########################################################################
-#
-#
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -urN twin-3.1.1/intp32/fp87.c twin/intp32/fp87.c
--- twin-3.1.1/intp32/fp87.c	Fri Oct 24 16:46:22 1997
+++ twin/intp32/fp87.c	Sat Nov  1 21:31:17 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*    
 	fp87.c	1.8
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -26,6 +43,7 @@
 
 	mailto:twin@willows.com 
 
+changes for use with dosemu-0.67 1997/10/20 vignani@mbox.vol.it
  */
 
 #include "hsw_interp.h"
@@ -120,6 +138,12 @@
 ENV87 hsw_env87;
 
 extern Interp_ENV *envp_global;
+
+#ifdef DOSEMU
+#  define fprintf our_fprintf
+#  define our_fprintf(stream, args...) error(##args)
+#endif
+
 
 void
 hsw_fp87_00m(unsigned char *mem_ref)
diff -urN twin-3.1.1/intp32/hsw_interp.h twin/intp32/hsw_interp.h
--- twin-3.1.1/intp32/hsw_interp.h	Fri Oct 24 16:46:23 1997
+++ twin/intp32/hsw_interp.h	Sat Nov  1 21:32:11 1997
@@ -1,27 +1,46 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /**********************************************************************
 
     @(#)hsw_interp.h	1.23
   
     Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
 The maintainer of the Willows TWIN Libraries may be reached (Email) 
 at the address twin@willows.com	
 
+changes for use with dosemu-0.67 1997/10/20 vignani@mbox.vol.it
+
 *********************************************************************/
 
 #ifndef hsw_interp__h
@@ -33,6 +52,8 @@
 #include "BinTypes.h"
 #include "DPMI.h"
 
+#ifndef DOSEMU_TYPESONLY
+
 #define ADDbfrm		0x00
 #define ADDwfrm		0x01
 #define ADDbtrm		0x02
@@ -415,6 +436,8 @@
 #define INTERRUPT_FLAG		0x0200
 #define DIRECTION_FLAG		0x0400
 #define OVERFLOW_FLAG		0x0800
+#define IOPL_FLAG_MASK		0x3000
+#define NESTED_FLAG		0x4000
 #define BYTE_FL			0x8000
 
 #define BYTE_OP 0x45
@@ -515,7 +538,9 @@
 #define LONG_SS interp_var->seg_regs[3]
 #define LONG_FS interp_var->seg_regs[4]
 #define LONG_GS interp_var->seg_regs[5]
+
 #define OVERRIDE interp_var->seg_regs[6]
+#define INVALID_OVR	((unsigned char *)(-1l))
 
 #define SIGNb (res & 0x80)
 #define SIGNw ((res & 0x8000) >> 8)
@@ -544,6 +569,17 @@
 
 #define JUMP(lp)	PC = PC + 2 +(signed char)(*(lp)); 
 
+#if defined(DOSEMU) && defined(__i386__)
+#define PUSHWORD(w) {env->rsp.sp.sp-=2; \
+		*((unsigned short *)(LONG_SS+env->rsp.sp.sp))=(w);}
+#define PUSHQUAD(dw) {env->rsp.sp.sp-=4; \
+		*((unsigned long *)(LONG_SS+env->rsp.sp.sp))=(dw);}
+
+#define POPWORD(w)  {w=*((unsigned short *)(LONG_SS+env->rsp.sp.sp));\
+		env->rsp.sp.sp+=2;}
+#define POPQUAD(dw)  {dw=*((unsigned long *)(LONG_SS+env->rsp.sp.sp));\
+		env->rsp.sp.sp+=4;}
+#else
 #define PUSHWORD(w) {unsigned char *sp=interp_var->seg_regs[3]+env->rsp.sp.sp; \
 		*(sp-2)=w; \
 		*(sp-1)=w>>8; \
@@ -563,9 +599,28 @@
 			(((unsigned long) *(sp+2))<<16) | \
 			(((unsigned long) *(sp+3))<<24); \
 		env->rsp.sp.sp+=4;}
+#endif	/* DOSEMU */
 
 #define SELECTOR_PADDRESS(sel) GetPhysicalAddress(sel)
 
+#ifdef DOSEMU
+#define SET_SEGREG(lp,sel) { \
+	WORD wFlags; \
+	if (vm86f) lp = (unsigned char *)(sel<<4); \
+	else if ((sel >> 3) == 0) \
+	    lp = 0; \
+	else { \
+	    wFlags = GetSelectorFlags(sel); \
+	    if (!(wFlags & DF_PRESENT)) { \
+	        if (!LoadSegment(sel)) { \
+		    error("INTP32: failed to load selector %x\n",(int)sel); \
+		    FatalAppExit(0,NULL); \
+	        } \
+	    } \
+	    lp = GetPhysicalAddress(sel); \
+	} \
+}
+#else
 #define SET_SEGREG(lp,sel) { \
 	WORD wFlags; \
 	char prnt_buf[40]; \
@@ -584,6 +639,9 @@
 	    lp = GetPhysicalAddress(sel); \
 	} \
 }
+#endif	/* DOSEMU */
+
+#endif	/* DOSEMU_TYPESONLY */
 
 typedef struct tagENV87
 {   double          fpregs[8];  /* floating point register stack */
@@ -1175,6 +1233,8 @@
 		} word;
 } MULT;
 
+#ifndef DOSEMU_TYPESONLY
+
 #define CARRY interp_var->flags_czsp.word16.carry
 #define RES_32 interp_var->flags_czsp.res
 #define RES_16 interp_var->flags_czsp.word16.res16
@@ -1196,26 +1256,154 @@
 
 #define IS_MODE_REG interp_var->mode_reg
 
-#define ALLOW_OVERRIDE(default) (((interp_var->seg_regs[6]))?interp_var->seg_regs[6]:default)
+#define ALLOW_OVERRIDE(default) ((interp_var->seg_regs[6]!=INVALID_OVR)?interp_var->seg_regs[6]:default)
 #define FETCH_XREG(addr) *(unsigned short *)addr
 #define FETCH_EREG(addr) *(DWORD *)addr
 #define PUT_XREG(addr,data) *(unsigned short *)addr=data
 #define PUT_EREG(addr,data) *(DWORD *)addr=data
+#ifdef DOSEMU
+#define IS_CF_SETD ((((src1 ^ src2) & (src1 ^ res)) | (src1 & src2)) >> 31)
+#else	/* buggy version */
 #define IS_CF_SETD ((((src1 ^ src2 ) & ~res) | (src1 & src2)) >> 31)
+#endif
 #define SETDFLAGS { DWORD res1=res;\
 RES_16 = ((res >> 24) << 8) | (res & 0xff); CARRY = IS_CF_SETD; BYTE_FLAG = 0; if(res1) RES_8 |= 0x1;\
 SRC1_16 = ((src1 >> 24) << 8) | (src1 & 0xff);\
 SRC2_16 = ((src2 >> 24) << 8) | (src2 & 0xff);}
 
+#if defined(DOSEMU) && defined(__i386__)
+#define	GETWORD(p)	(unsigned short)*((unsigned short *)(p))
+#define PUTWORD(p,w)	{*((unsigned short *)(p))=(unsigned short)(w);}
+#define PUTDWORD(p,dw)	{*((unsigned long *)(p))=(unsigned long)(dw);}
+#define GETDWORD(p)	(unsigned long)*((unsigned long *)(p))
+#else
 #include "Endian.h"
+#endif
 
 #define	FETCH_WORD	GETWORD
 #define	FETCH_QUAD	GETDWORD
 #define	PUT_WORD	PUTWORD
 #define	PUT_QUAD	PUTDWORD
 
+#ifdef DOSEMU
+#include "cpu-emu.h"
+#include "dosemu_debug.h"
+
+extern BOOL vm86f;
+#else
+#define error(s...)	fprintf(stderr,##s)
 extern void INT_handler(int, ENV *);
+#endif
+extern BOOL code32, data32;
 extern void FatalAppExit(UINT, LPCSTR);
 
 typedef void (*FUNCT_PTR)();
+
+#ifdef DEBUG
+extern void e_debug (Interp_ENV *env, unsigned char *P0, unsigned char *PC,
+  	Interp_VAR *interp_var);
+#endif
+
+extern unsigned char *
+  hsw_interp_16_16 (Interp_ENV *env, unsigned char *P0, unsigned char *PC,
+  	Interp_VAR *interp_var, int *err);
+extern unsigned char *
+  hsw_interp_16_32 (Interp_ENV *env, unsigned char *P0, unsigned char *PC,
+  	Interp_VAR *interp_var, int *err);
+extern unsigned char *
+  hsw_interp_32_16 (Interp_ENV *env, unsigned char *P0, unsigned char *PC,
+  	Interp_VAR *interp_var, int *err);
+extern unsigned char *
+  hsw_interp_32_32 (Interp_ENV *env, unsigned char *P0, unsigned char *PC,
+  	Interp_VAR *interp_var, int *err);
+
+extern int
+  hsw_modrm_16_byte (Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var);
+extern int
+  hsw_modrm_16_word (Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var);
+extern int
+  hsw_modrm_16_quad (Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var);
+extern int
+  hsw_modrm_32_byte (Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var);
+extern int
+  hsw_modrm_32_word (Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var);
+extern int
+  hsw_modrm_32_quad (Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var);
+
+#ifdef DOSEMU
+#define e_AL env->rax.x.x.h.l
+#define e_AH env->rax.x.x.h.h
+#define e_AX env->rax.x.x.x
+#define e_EAX env->rax.e
+#define e_BL env->rbx.x.x.h.l
+#define e_BH env->rbx.x.x.h.h
+#define e_BX env->rbx.x.x.x
+#define e_EBX env->rbx.e
+#define e_CL env->rcx.x.x.h.l
+#define e_CH env->rcx.x.x.h.h
+#define e_CX env->rcx.x.x.x
+#define e_ECX env->rcx.e
+#define e_DL env->rdx.x.x.h.l
+#define e_DH env->rdx.x.x.h.h
+#define e_DX env->rdx.x.x.x
+#define e_EDX env->rdx.e
+#define e_SI env->rsi.si.si
+#define e_ESI env->rsi.esi
+#define e_DI env->rdi.di.di
+#define e_EDI env->rdi.edi
+#define e_BP env->rbp.bp.bp
+#define e_EBP env->rbp.ebp
+#define e_SP env->rsp.sp.sp
+#define e_ESP env->rsp.esp
+#define e_CS env->cs.cs
+#define e_DS env->ds.ds
+#define e_ES env->es.es
+#define e_SS env->ss.ss
+#define e_FS env->fs.fs
+#define e_GS env->gs.gs
+#define e_EIP env->trans_addr
+#define e_EFLAGS env->flags
+
+#endif	/* DOSEMU */
+#endif	/* DOSEMU_TYPESONLY */
+
+/*
+ * INT 00 C  - CPU-generated - DIVIDE ERROR
+ * INT 01 C  - CPU-generated - SINGLE STEP
+ * INT 02 C  - external hardware - NON-MASKABLE INTERRUPT
+ * INT 03 C  - CPU-generated - BREAKPOINT
+ * INT 04 C  - CPU-generated - INTO DETECTED OVERFLOW
+ * INT 05 C  - CPU-generated (80186+) - BOUND RANGE EXCEEDED
+ * INT 06 C  - CPU-generated (80286+) - INVALID OPCODE
+ * INT 07 C  - CPU-generated (80286+) - PROCESSOR EXTENSION NOT AVAILABLE
+ * INT 08 C  - CPU-generated (80286+) - DOUBLE EXCEPTION DETECTED
+ * INT 09 C  - CPU-generated (80286,80386) - PROCESSOR EXTENSION PROTECTION ERROR
+ * INT 0A CP - CPU-generated (80286+) - INVALID TASK STATE SEGMENT
+ * INT 0B CP - CPU-generated (80286+) - SEGMENT NOT PRESENT
+ * INT 0C C  - CPU-generated (80286+) - STACK FAULT
+ * INT 0D C  - CPU-generated (80286+) - GENERAL PROTECTION VIOLATION
+ * INT 0E C  - CPU-generated (80386+ native mode) - PAGE FAULT
+ * INT 10 C  - CPU-generated (80286+) - COPROCESSOR ERROR
+ * INT 11    - CPU-generated (80486+) - ALIGNMENT CHECK
+ * INT 12    - CPU-generated (Pentium) - MACHINE CHECK EXCEPTION
+ */
+#define EXCP00_DIVZ	1
+#define EXCP01_SSTP	2
+#define EXCP02_NMI	3
+#define EXCP03_INT3	4
+#define EXCP04_INTO	5
+#define EXCP05_BOUND	6
+#define EXCP06_ILLOP	7
+#define EXCP07_PREX	8
+#define EXCP08_DBLE	9
+#define EXCP09_XERR	10
+#define EXCP0A_TSS	11
+#define EXCP0B_NOSEG	12
+#define EXCP0C_STACK	13
+#define EXCP0D_GPF	14
+#define EXCP0E_PAGE	15
+#define EXCP10_COPR	17
+#define EXCP11_ALGN	18
+#define EXCP12_MCHK	19
+
 #endif /* hsw_interp__h */
diff -urN twin-3.1.1/intp32/interp_16_32.c twin/intp32/interp_16_32.c
--- twin-3.1.1/intp32/interp_16_32.c	Fri Oct 24 16:46:23 1997
+++ twin/intp32/interp_16_32.c	Sat Nov  1 21:32:44 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*    
 	interp_16_32.c	1.13
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -26,6 +43,7 @@
 
 	mailto:twin@willows.com 
 
+changes for use with dosemu-0.67 1997/10/20 vignani@mbox.vol.it
  */
 
 #include <stdio.h>
@@ -45,7 +63,11 @@
 extern long start_count;
 extern long end_count;
 extern int granularity;
+#ifdef DOSEMU
+extern long instr_count;
+#else
 extern int instr_count;
+#endif
 extern int dbx_cs;
 extern int dbx_ip;
 extern int dbx_stop_count;
@@ -62,17 +84,26 @@
     hsw_fp87_reg2[], hsw_fp87_reg3[], hsw_fp87_reg4[],
     hsw_fp87_reg5[], hsw_fp87_reg6[], hsw_fp87_reg7[]; 
 
-extern unsigned char *  
-hsw_interp_32_32(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var);
+extern unsigned int
+  trans_interp_flags (Interp_ENV *env, Interp_VAR * interp_var);
+extern void
+  trans_flags_to_interp (Interp_ENV *env, Interp_VAR *interp_var, unsigned int flags);
+
 
 unsigned char *
-hsw_interp_16_32(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var)
+hsw_interp_16_32 (Interp_ENV *env, unsigned char *P0, unsigned char *PC,
+	Interp_VAR *interp_var, int *err)
 {
 #ifdef DEBUG
+#ifdef DOSEMU
+    e_debug(env, P0, PC, interp_var);
+#else
     if(ad32_print) { printf("%04x:%04x %02x %02x %04x %04x %04x %04x %04x %04x %04x %04x %s %d\n", SHORT_CS_16, PC-(LONG_CS),*PC, *(PC+1), AX, BX, CX, DX, SI, DI, BP, SP, decode(*PC, *(PC+1)), instr_count);
 	fflush(stdout);
 	}
 #endif
+#endif
+    *err = 0;
     override:
     switch (*PC) {
 	case ADDbfrm: {
@@ -1269,10 +1300,16 @@
 	case SEGgs:
 	    OVERRIDE = LONG_GS;
 	    PC+=1; goto override;
-	case OPERoverride:    /* 32 bit operand, 16 bit addressing */
-	    return (hsw_interp_32_32(env, PC+1, interp_var));
-	case ADDRoverride:    /* 16 bit operand, 32 bit addressing */
-	    PC += 1; return(PC);
+	case OPERoverride:	/* 0x66: 32 bit operand, 16 bit addressing */
+	    if (!data32)
+		return (hsw_interp_32_32 (env, P0, PC+1, interp_var, err));
+	    PC += 1;
+	    goto override;
+	case ADDRoverride:	/* 0x67: 16 bit operand, 32 bit addressing */
+	    if (code32)
+		return (hsw_interp_16_16 (env, P0, PC+1, interp_var, err));
+	    PC += 1;
+	    goto override;
 	case IMULwrm: {
 	    int res, src1, src2; unsigned char *mem_ref;
 	    PC += hsw_modrm_32_word(env,PC,interp_var);
@@ -1681,7 +1718,7 @@
 		}
 	    }}
 	case LEA: {
-	    int temp, modrm;
+	    int temp=0, modrm;
 	    modrm = *(PC+1);
 	    switch (modrm >> 6) {
 		case 0:
@@ -1691,7 +1728,7 @@
 		    case 2: temp = EDX; break;
 		    case 3: temp = EBX; break;
 		    case 4: /* SIB form */ {
-			int scale, base, index;
+			int scale, base=0, index=0;
 			int sib = *(PC + 2);
 			scale = sib >> 6;
 			switch ((sib>>3)&7) {
@@ -1727,7 +1764,7 @@
 		    case 2: temp = EDX + *(signed char *)(PC+2); break;
 		    case 3: temp = EBX + *(signed char *)(PC+2); break;
 		    case 4: /* SIB form */ {
-			int scale, base, index;
+			int scale, base=0, index=0;
 			int sib = *(PC + 2);
 			scale = sib >> 6;
 			switch ((sib>>3)&7) {
@@ -1763,7 +1800,7 @@
 		    case 2: temp = EDX + FETCH_QUAD(PC+2); break;
 		    case 3: temp = EBX + FETCH_QUAD(PC+2); break;
 		    case 4: /* SIB form */ {
-			int scale, base, index;
+			int scale, base=0, index=0;
 			int sib = *(PC + 2);
 			scale = sib >> 6;
 			switch ((sib>>3)&7) {
@@ -2216,7 +2253,7 @@
 	    PC += hsw_modrm_32_byte(env,PC,interp_var);
 	    *MEM_REF = *PC; PC += 1; return (PC);
 	case MOVwirm: {
-	    int temp; unsigned char *mem_ref;
+	    /*int temp;*/ unsigned char *mem_ref;
 	    PC += hsw_modrm_32_word(env,PC,interp_var);
 	    mem_ref = MEM_REF;
 	    if (IS_MODE_REG) {
@@ -2651,7 +2688,7 @@
             int reg = (*(PC+1) & 7);
 	    unsigned int funct = (unsigned int)(*(PC+1) & 0x38) >> 3;
 	    PC += hsw_modrm_32_word(env,PC,interp_var);
-	    if (IS_MODE_REG) hsw_fp87_reg0[funct](MEM_REF);
+	    if (IS_MODE_REG) hsw_fp87_reg0[funct](reg);
 	    else hsw_fp87_mem0[funct](MEM_REF);
 	    } return (PC);
 	case ESC1: {
@@ -2708,6 +2745,10 @@
 	    int count = CX;
 
 #ifdef DEBUG
+#ifdef DOSEMU
+	instr_count += count;
+	e_debug(env, P0, PC, interp_var);
+#else
 if((instr_count++)==start_count)print=1;
 if(instr_count==end_count)print=0;
     if(print && (!(instr_count % granularity))){
@@ -2729,6 +2770,7 @@
 fflush(stdout);
 }
 #endif
+#endif
 
 	    PC += 2;
 segrepne:
@@ -2737,8 +2779,13 @@
 		case INSw:
 		case OUTSb:
 		case OUTSw:
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+		    goto not_implemented;
+#else
 		    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 		    exit(1);
+#endif
 		case MOVSb: {
 		    unsigned char *src, *dest;
 		    if (count == 0) return (PC);
@@ -2776,7 +2823,7 @@
 		    } }
 		case CMPSb: {
 		    unsigned char *src, *dest;
-		    unsigned int res, src1, src2;
+		    unsigned int res, src1=0, src2=0;
 		    if (count == 0) return (PC);
 		    src = ALLOW_OVERRIDE(LONG_DS) + (ESI);
 		    dest = LONG_ES + EDI;
@@ -2823,8 +2870,8 @@
 		    } return (PC);
 		case CMPSw: {
 		    unsigned char *src, *dest;
-		    unsigned int res, src1;
-		    int src2;
+		    unsigned int res, src1=0;
+		    int src2=0;
 		    if (count == 0) return (PC);
 		    src = ALLOW_OVERRIDE(LONG_DS) + (ESI);
 		    dest = LONG_ES + EDI;
@@ -3055,6 +3102,10 @@
 	    int count = CX;
 
 #ifdef DEBUG
+#ifdef DOSEMU
+	instr_count += count;
+	e_debug(env, P0, PC, interp_var);
+#else
 if((instr_count++)==start_count)print=1;
 if(instr_count==end_count)print=0;
     if(print && (!(instr_count % granularity))){
@@ -3076,6 +3127,7 @@
 fflush(stdout);
 }
 #endif
+#endif
 
 	    PC += 2;
 segrep:
@@ -3084,8 +3136,13 @@
 		case INSw:
 		case OUTSb:
 		case OUTSw:
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+		    goto not_implemented;
+#else
 		    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 		    exit(1);
+#endif
 		case MOVSb: {
 		    unsigned char *src, *dest;
 		    if (count == 0) return (PC);
@@ -3123,7 +3180,7 @@
 		    } }
 		case CMPSb: {
 		    unsigned char *src, *dest;
-		    unsigned int res, src1, src2;
+		    unsigned int res, src1=0, src2=0;
 		    if (count == 0) return (PC);
 		    src = ALLOW_OVERRIDE(LONG_DS) + (ESI);
 		    dest = LONG_ES + EDI;
@@ -3170,8 +3227,8 @@
 		    } return (PC);
 		case CMPSw: {
 		    unsigned char *src, *dest;
-		    unsigned int res, src1;
-		    int src2;
+		    unsigned int res, src1=0;
+		    int src2=0;
 		    if (count == 0) return (PC);
 		    src = ALLOW_OVERRIDE(LONG_DS) + (ESI);
 		    dest = LONG_ES + EDI;
@@ -3728,11 +3785,24 @@
         } return(PC);
  
     not_implemented:
-	fprintf(stderr," 16/32 nonimplemented instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2),
-		SHORT_CS_16,PC-LONG_CS,PC);
+	error(" 16/32 nonimplemented instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2),
+		SHORT_CS_16,PC-LONG_CS,(int)PC);
+#ifdef DOSEMU
+	*err = EXCP06_ILLOP; return (P0);
+#else
 	exit(1);
+#endif
+
+    not_permitted:
+#ifdef DOSEMU
+	*err = EXCP0D_GPF; return P0;
+#endif
     illegal_op:
-	fprintf(stderr," 16/32 illegal instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2), 
-                SHORT_CS_16,PC-LONG_CS,PC);
+	error(" 16/32 illegal instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2), 
+                SHORT_CS_16,PC-LONG_CS,(int)PC);
+#ifdef DOSEMU
+	*err = EXCP06_ILLOP; return (P0);
+#else
         exit(1); 
+#endif
 }
diff -urN twin-3.1.1/intp32/interp_32_16.c twin/intp32/interp_32_16.c
--- twin-3.1.1/intp32/interp_32_16.c	Fri Oct 24 16:46:23 1997
+++ twin/intp32/interp_32_16.c	Sat Nov  1 21:34:01 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*    
 	interp_32_16.c	1.15
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -26,9 +43,13 @@
 
 	mailto:twin@willows.com 
 
+changes for use with dosemu-0.67 1997/10/20 vignani@mbox.vol.it
  */
 
 #include <stdio.h>
+#ifdef linux
+#include <asm/bitops.h>
+#endif
 #include "Log.h"
 #include "hsw_interp.h"
 #include "mod_rm.h"
@@ -46,7 +67,11 @@
 extern long start_count;
 extern long end_count;
 extern int granularity;
+#ifdef DOSEMU
+extern long instr_count;
+#else
 extern int instr_count;
+#endif
 extern int dbx_cs;
 extern int dbx_ip;
 extern int dbx_stop_count;
@@ -63,18 +88,33 @@
     hsw_fp87_reg2[], hsw_fp87_reg3[], hsw_fp87_reg4[],
     hsw_fp87_reg5[], hsw_fp87_reg6[], hsw_fp87_reg7[]; 
 
-extern unsigned char *   
-hsw_interp_32_32(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var); 
+extern unsigned int
+  trans_interp_flags (Interp_ENV *env, Interp_VAR *interp_var);
+extern void
+  trans_flags_to_interp (Interp_ENV *env, Interp_VAR *interp_var, unsigned int flags);
+
+extern REGISTER PortIO (DWORD, DWORD, UINT, BOOL);
+
+#ifdef DOSEMU
+#  define fprintf our_fprintf
+#  define our_fprintf(stream, args...) error(##args)
+#endif
 
 unsigned char *
-hsw_interp_32_16(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var)
+hsw_interp_32_16 (Interp_ENV *env, unsigned char *P0, unsigned char *PC,
+	Interp_VAR *interp_var, int *err)
 {
 #ifdef DEBUG
+    e_debug(env, P0, PC, interp_var);
+#ifdef DOSEMU
+#else
     if(op32_print){
          printf("%04x:%04x %02x %02x %04x %04x %04x %04x %04x %04x %04x %04x %s %d\n", SHORT_CS_16, PC-(LONG_CS),*PC, *(PC+1), AX, BX, CX, DX, SI, DI, BP, SP, decode(*PC, *(PC+1)), instr_count);
 	fflush(stdout);
 	}
 #endif
+#endif
+    *err = 0;
     override:
     switch (*PC) {
 	case ADDwfrm: {
@@ -184,6 +224,9 @@
 			    } return (PC);
 			case 2: /* LLDT */ /* Privileged */
 			    /* Load Local Descriptor Table Register */
+#ifdef DOSEMU
+			    if (vm86f) goto not_permitted;
+#endif
 			    PC = PC +1 + hsw_modrm_16_quad(env,PC + 1,interp_var);
 			    return (PC);
 			case 3: /* LTR */ {
@@ -243,11 +286,17 @@
 			    } return (PC);
 			case 2: /* LGDT */ /* Privileged */
 			    /* Load Global Descriptor Table Register */
+#ifdef DOSEMU
+			    if (vm86f) goto not_permitted;
+#endif
 			    PC = PC+1+hsw_modrm_16_quad(env,PC + 1,interp_var);
 		goto not_implemented;
 			    return (PC);
 			case 3: /* LIDT */ /* Privileged */
 			    /* Load Interrupt Descriptor Table Register */
+#ifdef DOSEMU
+			    if (vm86f) goto not_permitted;
+#endif
 			    PC = PC+1+hsw_modrm_16_quad(env,PC + 1,interp_var);
 		goto not_implemented;
 			    return (PC);
@@ -263,8 +312,11 @@
 			case 5: /* Illegal */
 		goto illegal_op;
 			case 6: /* LMSW */ /* Privileged */
-		goto not_implemented;
 			    /* Load Machine Status Word */
+#ifdef DOSEMU
+			    if (vm86f) goto not_permitted;
+#endif
+			    goto not_implemented;
 			    PC = PC+1+hsw_modrm_16_quad(env,PC + 1,interp_var);
 			    return (PC);
 			case 7: /* Illegal */
@@ -272,7 +324,7 @@
 		    }
 		case 0x02: /* LAR */ {
 		    /* Load Access Rights Byte */
-		    int temp; unsigned char *mem_ref;
+		    /*int temp;*/ unsigned char *mem_ref;
 		    PC += 1; PC += hsw_modrm_16_quad(env,PC,interp_var);
 		    mem_ref = MEM_REF;
 		goto not_implemented;
@@ -280,7 +332,7 @@
 		    } return (PC);
 		case 0x03: /* LSL */ {
 		    /* Load Segment Limit */
-		    int temp; unsigned char *mem_ref;
+		    /*int temp;*/ unsigned char *mem_ref;
 		    PC += 1; PC += hsw_modrm_16_quad(env,PC,interp_var);
 		    mem_ref = MEM_REF;
 		goto not_implemented;
@@ -288,6 +340,9 @@
 		    } return (PC);
 		case 0x06: /* CLTS */ /* Privileged */
 		    /* Clear Task State Register */
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+#endif
 		    PC += 2; return (PC);
 		case 0x08: /* INVD */
 		    /* INValiDate cache */
@@ -301,7 +356,10 @@
 		case 0x23: /* MOVrddd */ /* Privileged */
 		case 0x24: /* MOVtdrd */ /* Privileged */
 		case 0x26: /* MOVrdtd */ /* Privileged */
-		goto not_implemented;
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+#endif
+		    goto not_implemented;
 		case 0x80: /* JOimmdisp */
 /*		    if (IS_OF_SET) {
 			unsigned long temp = FETCH_QUAD(PC+2);
@@ -679,9 +737,24 @@
 		    CARRY = carry;
 		    } return (PC);
 		case 0xaf: { /* IMULregrm */
+#ifdef DOSEMU
+		    int64_t res, mlt;
+		    unsigned char *mem_ref;
+		    unsigned long himr;
+		    PC = PC + 1 + hsw_modrm_16_quad (env, PC + 1, interp_var);
+		    res = *EREG1; mem_ref = MEM_REF;
+		    if (IS_MODE_REG)
+			mlt = FETCH_EREG(mem_ref);
+		    else
+			mlt = FETCH_QUAD(mem_ref);
+		    res *= mlt;
+		    *EREG1 = (u_int32_t)res;
+		    himr = (u_int32_t)((res<0? -res:res)>>32);
+#else
                     MULT resm, src1m, src2m, mulr[4];
 		    int sg1=1, sg2=1;
 		    unsigned char *mem_ref;
+		    unsigned long himr;
 		    PC = PC+1+hsw_modrm_16_quad(env,PC+1,interp_var);
                     src1m.longw = *EREG1; mem_ref = MEM_REF;
 		    if(IS_MODE_REG)
@@ -695,12 +768,13 @@
 		    mulr[2].longw = src1m.word.snjr * src2m.word.jnr;
 		    mulr[3].longw = src1m.word.snjr * src2m.word.snjr;
 		    src1m.longw = mulr[0].word.snjr + mulr[1].word.jnr + mulr[2].word.jnr;
-		    src2m.longw = mulr[1].word.snjr + mulr[2].word.snjr + mulr[3].longw + src1m.word.snjr;
+		    himr = src2m.longw = mulr[1].word.snjr + mulr[2].word.snjr + mulr[3].longw + src1m.word.snjr;
 		    resm.word.jnr = mulr[0].word.jnr;
 		    resm.word.snjr = src1m.word.jnr;
 		    *EREG1 = ((sg1==sg2)? resm.longw: -resm.longw);
+#endif
 		    RES_32 = 0;
-		    if(src2m.longw) { SRC1_16 = SRC2_16 = 0x8000;
+		    if(himr) { SRC1_16 = SRC2_16 = 0x8000;
 			CARRY = 1; }
 		    else SRC1_16 = SRC2_16 = 0;
                     } return(PC);
@@ -1146,7 +1220,7 @@
                 AL += 6;
                 SET_AF
             } else CLEAR_AF
-            if ((AL > 0x90) || (IS_CF_SET)) {
+            if (((AL & 0xf0) > 0x90) || (IS_CF_SET)) {
                 AL += 0x60;
                 SET_CF;
             } else CLEAR_CF;
@@ -1201,7 +1275,7 @@
 		AL -= 6;
 		SET_AF;
 	    } else CLEAR_AF;
-	    if ((AL > 0x90) || (IS_CF_SET)) {
+	    if (((AL & 0xf0) > 0x90) || (IS_CF_SET)) {
 		AL -= 0x60;
 		SET_CF;
 	    } else CLEAR_CF;
@@ -1538,10 +1612,16 @@
 	case SEGgs:
 	    OVERRIDE = LONG_GS;
 	    PC+=1; goto override;
-	case OPERoverride:    /* 32 bit operand, 16 bit addressing */
-	    PC += 1; goto override;
-	case ADDRoverride:    /* 32 bit operand, 32 bit addressing */
-	    return (hsw_interp_32_32(env, PC+1,interp_var));
+	case OPERoverride:	/* 0x66: 32 bit operand, 16 bit addressing */
+	    if (data32)
+		return (hsw_interp_16_16 (env, P0, PC+1, interp_var, err));
+	    PC += 1;
+	    goto override;
+	case ADDRoverride:	/* 0x67: 16 bit operand, 32 bit addressing */
+	    if (!code32)
+		return (hsw_interp_32_32 (env, P0, PC+1, interp_var, err));
+	    PC += 1;
+	    goto override;
 	case PUSHwi: {
 	    unsigned char *sp = LONG_SS + SP;
 	    *(sp - 1) = *(PC + 4);
@@ -1551,8 +1631,23 @@
 	    SP -= 4;
 	    } PC += 5; return (PC);
         case IMULwrm: {
+#ifdef DOSEMU
+	    int64_t res, mlt;
+	    unsigned char *mem_ref;
+	    unsigned long himr;
+	    PC += hsw_modrm_16_quad (env, PC, interp_var);
+	    res = *EREG1; mem_ref = MEM_REF;
+	    if (IS_MODE_REG)
+		mlt = FETCH_EREG(mem_ref);
+	    else
+		mlt = FETCH_QUAD(mem_ref);
+	    res *= mlt;
+	    *EREG1 = (u_int32_t)res;
+	    himr = (u_int32_t)((res<0? -res:res)>>32);
+#else
             MULT resm, src1m, src2m, mulr[4];
             unsigned char *mem_ref, sg1=1, sg2=1;
+	    unsigned long himr;
             PC += hsw_modrm_16_quad(env,PC,interp_var);
             src2m.longw = FETCH_QUAD(PC); PC += 4; mem_ref = MEM_REF;
             if (IS_MODE_REG)
@@ -1566,12 +1661,13 @@
             mulr[2].longw = src1m.word.snjr * src2m.word.jnr;
             mulr[3].longw = src1m.word.snjr * src2m.word.snjr;
             src1m.longw = mulr[0].word.snjr + mulr[1].word.jnr + mulr[2].word.jnr;
-            src2m.longw = mulr[1].word.snjr + mulr[2].word.snjr + mulr[3].longw + src1m.word.snjr;
+            himr = src2m.longw = mulr[1].word.snjr + mulr[2].word.snjr + mulr[3].longw + src1m.word.snjr;
             resm.word.jnr = mulr[0].word.jnr;
             resm.word.snjr = src1m.word.jnr;
             *EREG1 = ((sg1==sg2)? resm.longw: -resm.longw);
+#endif
             RES_32 = 0;
-            if(src2m.longw) { SRC1_16 = SRC2_16 = 0x8000;
+            if (himr) { SRC1_16 = SRC2_16 = 0x8000;
                 CARRY = 1; }
             else SRC1_16 = SRC2_16 = 0;
             } return(PC);
@@ -1907,7 +2003,7 @@
 		}
 	    }}
 	case LEA: {
-	    int temp, modrm;
+	    int temp=0, modrm;
 	    modrm = *(PC+1);
 	    switch (modrm >> 6) {
 		case 0:
@@ -2116,11 +2212,19 @@
 	    goto not_implemented;
 	case PUSHF: {
 	    DWORD temp;
+#ifdef DOSEMU
+	    if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK))
+		goto not_permitted;
+#endif
 	    temp =     trans_interp_flags(env, interp_var);    
 	    PUSHQUAD(temp);
 	    } PC += 1; return (PC);
 	case POPF: {
 	    unsigned long temp;
+#ifdef DOSEMU
+	    if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK))
+		goto not_permitted;
+#endif
 	    POPQUAD(temp);
 	    trans_flags_to_interp(env, interp_var, temp);
 	    } PC += 1; return (PC);
@@ -2414,7 +2518,7 @@
 	    SET_SEGREG(LONG_DS,temp);
 	    } return (PC);
 	case MOVwirm: {
-	    int temp; unsigned char *mem_ref;
+	    /*int temp;*/ unsigned char *mem_ref;
 	    PC += hsw_modrm_16_quad(env,PC,interp_var);
 	    mem_ref = MEM_REF;
 	    if (IS_MODE_REG) {
@@ -2856,9 +2960,13 @@
 	      } } } else  return (PC);
 	    }
 	case 0xd6:    /* illegal on 8086 and 80x86*/
+#ifdef DOSEMU
+	    goto illegal_op;
+#else
 	    fprintf(stderr,illegal_msg,PC,SHORT_CS_16,PC-LONG_CS);
 	    exit(1);
 	    PC += 1; return (PC);    
+#endif
 	case ESC0: {
 	    int funct = (*(PC+1) & 0x38);
 	    PC += hsw_modrm_16_quad(env,PC,interp_var);
@@ -2924,7 +3032,42 @@
 	    if (ECX == 0) {
 		JUMP((PC+1)); return (PC);
 	    } PC += 2; return (PC);
-
+#ifdef DOSEMU
+	case INw: {
+	      DWORD a = *(PC+1);
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((a&1)||(!test_bit(a+1, io_bitmap))) goto not_permitted;
+	      }
+	      AX = PortIO ((DWORD) *(++PC), 0, 32, FALSE);
+	    }
+	    PC += 1;
+	    return (PC);
+	case OUTw: {
+	      DWORD a = *(PC+1);
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((a&1)||(!test_bit(a+1, io_bitmap))) goto not_permitted;
+	      }
+	      PortIO ((DWORD) *(++PC), AX, 32, TRUE);
+	    }
+	    PC += 1;
+	    return (PC);
+	case INvw: {
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((DX>0x3ff)||(DX&1)||(!test_bit(DX+1, io_bitmap))) goto not_permitted;
+	      }
+	      AX = PortIO (DX, 0, 32, FALSE);
+	    }
+	    PC += 1;
+	    return (PC);
+	case OUTvw: {
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((DX>0x3ff)||(DX&1)||(!test_bit(DX+1, io_bitmap))) goto not_permitted;
+	      }
+	      PortIO (DX, AX, 32, TRUE);
+	    }
+	    PC += 1;
+	    return (PC);
+#endif 
 	case CALLd: /* {
 	    unsigned int ip = PC - LONG_CS + 3;
 	    PUSHQUAD(ip);
@@ -2955,6 +3098,10 @@
 	    int count = ECX;
 
 #ifdef DEBUG
+#ifdef DOSEMU
+	instr_count += count;
+	e_debug(env, P0, PC, interp_var);
+#else
 if((instr_count++)==start_count)print=1;
 if(instr_count==end_count)print=0;
     if(print && (!(instr_count % granularity))){
@@ -2976,6 +3123,7 @@
 fflush(stdout);
 }
 #endif
+#endif
 
 	    PC += 2;
 segrepne:
@@ -2984,8 +3132,13 @@
 		case INSw:
 		case OUTSb:
 		case OUTSw:
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+		    goto not_implemented;
+#else
 		    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 		    exit(1);
+#endif
 		case MOVSw: { /* MOVSD */
 		    unsigned char *src, *dest;
 		    if (count == 0) return (PC);
@@ -3013,8 +3166,8 @@
 		    } }
 		case CMPSw: {
 		    unsigned char *src, *dest;
-		    unsigned long res, src1;
-		    long src2;
+		    unsigned long res, src1=0;
+		    long src2=0;
 		    if (count == 0) return (PC);
 		    src = ALLOW_OVERRIDE(LONG_DS) + (SI);
 		    dest = LONG_ES + DI;
@@ -3171,6 +3324,10 @@
 	    int count = ECX;
 
 #ifdef DEBUG
+#ifdef DOSEMU
+	instr_count += count;
+	e_debug(env, P0, PC, interp_var);
+#else
 if((instr_count++)==start_count)print=1;
 if(instr_count==end_count)print=0;
     if(print && (!(instr_count % granularity))){
@@ -3192,6 +3349,7 @@
 fflush(stdout);
 }
 #endif
+#endif
 
 	    PC += 2;
 segrep:
@@ -3200,8 +3358,13 @@
 		case INSw:
 		case OUTSb:
 		case OUTSw:
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+		    goto not_implemented;
+#else
 		    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 		    exit(1);
+#endif
 		case MOVSw: {
 		    unsigned char *src, *dest;
 		    if (count == 0) return (PC);
@@ -3229,8 +3392,8 @@
 		    } }
 		case CMPSw: {
 		    unsigned char *src, *dest;
-		    unsigned long res, src1;
-		    long src2;
+		    unsigned long res, src1=0;
+		    long src2=0;
 		    if (count == 0) return (PC);
 		    src = ALLOW_OVERRIDE(LONG_DS) + (SI);
 		    dest = LONG_ES + DI;
@@ -3415,6 +3578,12 @@
 		    SETDFLAGS;
 		    } return (PC);
 		case 4: { /* MUL EAX */
+#ifdef DOSEMU
+		    u_int64_t res = (u_int64_t)EAX;
+		    res *= (u_int64_t)FETCH_EREG (mem_ref);
+		    EAX = (u_int32_t)res;
+		    EDX = (u_int32_t)(res>>32);
+#else
                     MULT resm, src1m, src2m, mulr[4];
                     src1m.longw = EAX;
                     src2m.longw = FETCH_EREG(mem_ref);
@@ -3428,12 +3597,19 @@
 		    resm.word.snjr = src1m.word.jnr;
 		    EAX = resm.longw;
 		    EDX = src2m.longw;
+#endif
 		    RES_32 = 0;
-		    if(src2m.longw) { SRC1_16 = SRC2_16 = 0x8000;
+		    if (EDX) { SRC1_16 = SRC2_16 = 0x8000;
 			CARRY = 1; }
 		    else SRC1_16 = SRC2_16 = 0;
                     } return(PC);
 		case 5: { /* IMUL EAX */
+#ifdef DOSEMU
+		    int64_t res = (int64_t)EAX;
+		    res *= (int64_t)FETCH_EREG (mem_ref);
+		    EAX = (u_int32_t)res;
+		    EDX = (u_int32_t)(res>>32);
+#else
                     MULT resm, src1m, src2m, mulr[4];
 		    int sg1=1, sg2=1;
                     src1m.longw = EAX;
@@ -3458,6 +3634,7 @@
 			EDX = ~EDX;
 			EDX += (sg1 & (~sg2))>>31; /* carry from eax */
 		    }
+#endif
 		    RES_32 = 0;
 		    if((EDX == 0) || (EDX == 0xffffffff)) { SRC1_16 = SRC2_16 = 0x8000;
 			CARRY = 1; }
@@ -3533,6 +3710,12 @@
 		    SETDFLAGS;
 		    } return (PC);
 		case 4: { /* MUL EAX */
+#ifdef DOSEMU
+		    u_int64_t res = (u_int64_t)EAX;
+		    res *= (u_int64_t)FETCH_QUAD (mem_ref);
+		    EAX = (u_int32_t)res;
+		    EDX = (u_int32_t)(res>>32);
+#else
                     MULT resm, src1m, src2m, mulr[4];
                     src1m.longw = EAX;
                     src2m.longw = FETCH_QUAD(mem_ref);
@@ -3546,12 +3729,19 @@
 		    resm.word.snjr = src1m.word.jnr;
 		    EAX = resm.longw;
 		    EDX = src2m.longw;
+#endif
 		    RES_32 = 0;
-		    if(src2m.longw) { SRC1_16 = SRC2_16 = 0x8000;
+		    if (EDX) { SRC1_16 = SRC2_16 = 0x8000;
 			CARRY = 1; }
 		    else SRC1_16 = SRC2_16 = 0;
                     } return(PC);
 		case 5: { /* IMUL EAX */
+#ifdef DOSEMU
+		    int64_t res = (int64_t)EAX;
+		    res *= (int64_t)FETCH_QUAD (mem_ref);
+		    EAX = (u_int32_t)res;
+		    EDX = (u_int32_t)(res>>32);
+#else
                     MULT resm, src1m, src2m, mulr[4];
 		    int sg1=1, sg2=1;
                     src1m.longw = EAX;
@@ -3576,6 +3766,7 @@
 			EDX = ~EDX;
 			EDX += (sg1 & (~sg2))>>31; /* carry from eax */
 		    }
+#endif
 		    RES_32 = 0;
 		    if((EDX == 0) || (EDX == 0xffffffff)) { SRC1_16 = SRC2_16 = 0x8000;
 			CARRY = 1; }
@@ -3785,10 +3976,23 @@
 
     not_implemented:
 	fprintf(stderr," 32/16 nonimplemented instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2),
-		SHORT_CS_16,PC-LONG_CS,PC);
+		SHORT_CS_16,PC-LONG_CS,(int)PC);
+#ifdef DOSEMU
+	*err = EXCP06_ILLOP; return (P0);
+#else
 	exit(1);
+#endif
+
+    not_permitted:
+#ifdef DOSEMU
+	*err = EXCP0D_GPF; return P0;
+#endif
     illegal_op:
 	fprintf(stderr," 32/16 illegal instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2), 
-                SHORT_CS_16,PC-LONG_CS,PC);
+                SHORT_CS_16,PC-LONG_CS,(int)PC);
+#ifdef DOSEMU
+	*err = EXCP06_ILLOP; return (P0);
+#else
         exit(1); 
+#endif
 }
diff -urN twin-3.1.1/intp32/interp_32_32.c twin/intp32/interp_32_32.c
--- twin-3.1.1/intp32/interp_32_32.c	Fri Oct 24 16:46:23 1997
+++ twin/intp32/interp_32_32.c	Sat Nov  1 21:34:32 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*    
 	interp_32_32.c	1.11
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -26,6 +43,7 @@
 
 	mailto:twin@willows.com 
 
+changes for use with dosemu-0.67 1997/10/20 vignani@mbox.vol.it
  */
 
 #include <stdio.h>
@@ -41,12 +59,16 @@
 extern int small_print;
 extern int stack_print;
 extern int segment_print;
-extern op32_print;
-extern ad32_print;
+extern int op32_print;
+extern int ad32_print;
 extern long start_count;
 extern long end_count;
 extern int granularity;
+#ifdef DOSEMU
+extern long instr_count;
+#else
 extern int instr_count;
+#endif
 extern int dbx_cs;
 extern int dbx_ip;
 extern int dbx_stop_count;
@@ -64,14 +86,31 @@
     hsw_fp87_reg2[], hsw_fp87_reg3[], hsw_fp87_reg4[],
     hsw_fp87_reg5[], hsw_fp87_reg6[], hsw_fp87_reg7[]; 
 
+extern unsigned int
+  trans_interp_flags (Interp_ENV * env, Interp_VAR * interp_var);
+extern void
+  trans_flags_to_interp (Interp_ENV * env, Interp_VAR * interp_var, unsigned int flags);
+
+#ifdef DOSEMU
+#  define fprintf our_fprintf
+#  define our_fprintf(stream, args...) error(##args)
+#endif
+
+
 unsigned char *
-hsw_interp_32_32(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var)
+hsw_interp_32_32(Interp_ENV *env, unsigned char *P0, unsigned char *PC,
+	Interp_VAR *interp_var, int *err)
 {
 #ifdef DEBUG
+#ifdef DOSEMU
+    e_debug(env, P0, PC, interp_var);
+#else
     if(op32_print || ad32_print) { printf("%04x:%04x %02x %02x %04x %04x %04x %04x %04x %04x %04x %04x %s %d\n", SHORT_CS_16, PC-(LONG_CS),*PC, *(PC+1), AX, BX, CX, DX, SI, DI, BP, SP, decode(*PC, *(PC+1)), instr_count);
 	fflush(stdout);
 	}
 #endif
+#endif
+    *err = 0;
     override:
     switch (*PC) {
 	case ADDbfrm:
@@ -291,7 +330,7 @@
 		    }
 		case 0x02: /* LAR */ {
 		    /* Load Access Rights Byte */
-		    int temp; unsigned char *mem_ref;
+		    /*int temp;*/ unsigned char *mem_ref;
 		    PC += 1; PC += hsw_modrm_32_quad(env,PC,interp_var);
 		    mem_ref = MEM_REF;
                 goto not_implemented;
@@ -299,7 +338,7 @@
 		    } return (PC);
 		case 0x03: /* LSL */ {
 		    /* Load Segment Limit */
-		    int temp; unsigned char *mem_ref;
+		    /*int temp;*/ unsigned char *mem_ref;
 		    PC += 1; PC += hsw_modrm_32_quad(env,PC,interp_var);
 		    mem_ref = MEM_REF;
                 goto not_implemented;
@@ -581,8 +620,23 @@
 		    CARRY = carry;
 		    } return (PC);
                 case 0xaf: /* IMULregrm */ {
+#ifdef DOSEMU
+			int64_t res, mlt;
+                        unsigned char *mem_ref;
+                        unsigned long himr;
+                        PC = PC+1+hsw_modrm_32_quad(env,PC+1,interp_var);
+                        res = *EREG1; mem_ref = MEM_REF;
+                        if (IS_MODE_REG)
+                            mlt = FETCH_EREG(mem_ref);
+                        else
+                            mlt = FETCH_QUAD(mem_ref);
+			res *= mlt;
+			*EREG1 = (u_int32_t)res;
+			himr = (u_int32_t)((res<0? -res:res)>>32);
+#else
                         MULT resm, src1m, src2m, mulr[4];
                         unsigned char *mem_ref, sg1=1, sg2=1;
+                        unsigned long himr;
                         PC = PC+1+hsw_modrm_32_quad(env,PC+1,interp_var);
                         src1m.longw = *EREG1; mem_ref = MEM_REF;
                         if (IS_MODE_REG)
@@ -596,12 +650,13 @@
                         mulr[2].longw = src1m.word.snjr * src2m.word.jnr;
                         mulr[3].longw = src1m.word.snjr * src2m.word.snjr;
                         src1m.longw = mulr[0].word.snjr + mulr[1].word.jnr + mulr[2].word.jnr;
-                        src2m.longw = mulr[1].word.snjr + mulr[2].word.snjr + mulr[3].longw + src1m.word.snjr;
+                        himr = src2m.longw = mulr[1].word.snjr + mulr[2].word.snjr + mulr[3].longw + src1m.word.snjr;
                         resm.word.jnr = mulr[0].word.jnr;
                         resm.word.snjr = src1m.word.jnr;
                         *EREG1 = ((sg1==sg2)? resm.longw: -resm.longw);
+#endif
                         RES_32 = 0;
-                        if(src2m.longw) { SRC1_16 = SRC2_16 = 0x8000;
+                        if (himr) { SRC1_16 = SRC2_16 = 0x8000;
                                 CARRY = 1; }
                         else SRC1_16 = SRC2_16 = 0;
                         } return(PC);
@@ -1424,10 +1479,16 @@
 	case SEGgs:
 	    OVERRIDE = LONG_GS;
 	    PC+=1; goto override;
-	case OPERoverride:    /* 32 bit operand, 32 bit addressing */
-	    PC += 1; goto override;
-	case ADDRoverride:    /* 32 bit operand, 32 bit addressing */
-	    PC += 1; goto override;
+	case OPERoverride:	/* 0x66: 16 bit operand, 32 bit addressing */
+	    if (!data32) { PC += 1; goto override; }
+	    PC = hsw_interp_16_32 (env, P0, PC+1, interp_var, err);
+	    if (*err) return P0;
+	    return (PC);
+	case ADDRoverride:	/* 0x67: 32 bit operand, 16 bit addressing */
+	    if (!code32) { PC += 1; goto override; }
+	    PC = hsw_interp_32_16 (env, P0, PC+1, interp_var, err);
+	    if (*err) return P0;
+	    return (PC);
 	case PUSHwi: {
             unsigned char *sp = LONG_SS + ESP;
             *(sp - 1) = *(PC + 4);
@@ -1437,8 +1498,23 @@
             ESP -= 4;
             } PC += 5; return (PC);
         case IMULwrm: {
+#ifdef DOSEMU
+	    int64_t res, mlt;
+            unsigned char *mem_ref;
+            unsigned long himr;
+            PC = PC+1+hsw_modrm_32_quad(env,PC+1,interp_var);
+            mlt = FETCH_QUAD(PC); PC += 4; mem_ref = MEM_REF;
+            if (IS_MODE_REG)
+                 res = FETCH_EREG(mem_ref);
+            else
+                 res = FETCH_QUAD(mem_ref);
+	    res *= mlt;
+	    *EREG1 = (u_int32_t)res;
+	    himr = (u_int32_t)((res<0? -res:res)>>32);
+#else
             MULT resm, src1m, src2m, mulr[4];
             unsigned char *mem_ref, sg1=1, sg2=1;
+            unsigned long himr;
             PC = PC+1+hsw_modrm_32_quad(env,PC+1,interp_var);
             src2m.longw = FETCH_QUAD(PC); PC += 4; mem_ref = MEM_REF;
             if (IS_MODE_REG)
@@ -1452,12 +1528,13 @@
             mulr[2].longw = src1m.word.snjr * src2m.word.jnr;
             mulr[3].longw = src1m.word.snjr * src2m.word.snjr;
             src1m.longw = mulr[0].word.snjr + mulr[1].word.jnr + mulr[2].word.jnr;
-            src2m.longw = mulr[1].word.snjr + mulr[2].word.snjr + mulr[3].longw + src1m.word.snjr;
+            himr = src2m.longw = mulr[1].word.snjr + mulr[2].word.snjr + mulr[3].longw + src1m.word.snjr;
             resm.word.jnr = mulr[0].word.jnr;
             resm.word.snjr = src1m.word.jnr;
             *EREG1 = ((sg1==sg2)? resm.longw: -resm.longw);
+#endif
             RES_32 = 0;
-            if(src2m.longw) { SRC1_16 = SRC2_16 = 0x8000;
+            if (himr) { SRC1_16 = SRC2_16 = 0x8000;
                 CARRY = 1; }
             else SRC1_16 = SRC2_16 = 0;
             } return(PC);
@@ -1789,7 +1866,7 @@
 		}
 	    }}
 	case LEA: {
-	    int temp, modrm;
+	    int temp=0, modrm;
 	    modrm = *(PC+1);
 	    switch (modrm >> 6) {
 		case 0:
@@ -1799,7 +1876,7 @@
 		    case 2: temp = EDX; break;
 		    case 3: temp = EBX; break;
 		    case 4: /* SIB form */ {
-			int scale, base, index;
+			int scale, base=0, index=0;
 			int sib = *(PC + 2);
 			scale = sib >> 6;
 			switch ((sib>>3)&7) {
@@ -1835,7 +1912,7 @@
 		    case 2: temp = EDX + *(signed char *)(PC+2); break;
 		    case 3: temp = EBX + *(signed char *)(PC+2); break;
 		    case 4: /* SIB form */ {
-			int scale, base, index;
+			int scale, base=0, index=0;
 			int sib = *(PC + 2);
 			scale = sib >> 6;
 			switch ((sib>>3)&7) {
@@ -1871,7 +1948,7 @@
 		    case 2: temp = EDX + FETCH_QUAD(PC+2); break;
 		    case 3: temp = EBX + FETCH_QUAD(PC+2); break;
 		    case 4: /* SIB form */ {
-			int scale, base, index;
+			int scale, base=0, index=0;
 			int sib = *(PC + 2);
 			scale = sib >> 6;
 			switch ((sib>>3)&7) {
@@ -2031,7 +2108,7 @@
 	    (env->flags & DIRECTION_FLAG)?(EDI-=4):(EDI+=4);
 	    } PC += 1; return (PC);
 	case SHIFTwi: {
-	    int temp, count; unsigned char *mem_ref;
+	    int temp=0, count; unsigned char *mem_ref;
 	    DWORD res, src1, src2;
 	    res = (*(PC+1)>>3)& 0x7;
 	    PC += hsw_modrm_32_quad(env,PC,interp_var);
@@ -2214,7 +2291,7 @@
 	    SET_SEGREG(LONG_DS,temp);
 	    } return (PC);
 	case MOVwirm: {
-	    DWORD temp; unsigned char *mem_ref;
+	    /*DWORD temp;*/ unsigned char *mem_ref;
 	    PC += hsw_modrm_32_quad(env,PC,interp_var);
 	    mem_ref = MEM_REF;
 	    if (IS_MODE_REG) {
@@ -2540,6 +2617,10 @@
 	    int count = ECX;
 
 #ifdef DEBUG
+#ifdef DOSEMU
+	instr_count += count;
+	e_debug(env, P0, PC, interp_var);
+#else
 if((instr_count++)==start_count)print=1;
 if(instr_count==end_count)print=0;
     if(print && (!(instr_count % granularity))){
@@ -2561,6 +2642,7 @@
 fflush(stdout);
 }
 #endif
+#endif
 
 	    PC += 2;
 segrepne:
@@ -2569,8 +2651,13 @@
 		case INSw:
 		case OUTSb:
 		case OUTSw:
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+		    goto not_implemented;
+#else
 		    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 		    exit(1);
+#endif
 		case MOVSw: { /* MOVSD */
 		    unsigned char *src, *dest;
 		    if (count == 0) return (PC);
@@ -2598,8 +2685,8 @@
 		    } }
 		case CMPSw: {
 		    unsigned char *src, *dest;
-		    unsigned long res, src1;
-		    long src2;
+		    unsigned long res, src1=0;
+		    long src2=0;
 		    if (count == 0) return (PC);
 		    src = ALLOW_OVERRIDE(LONG_DS) + (ESI);
 		    dest = LONG_ES + EDI;
@@ -2756,6 +2843,10 @@
 	    int count = ECX;
 
 #ifdef DEBUG
+#ifdef DOSEMU
+	instr_count += count;
+	e_debug(env, P0, PC, interp_var);
+#else
 if((instr_count++)==start_count)print=1;
 if(instr_count==end_count)print=0;
     if(print && (!(instr_count % granularity))){
@@ -2777,6 +2868,7 @@
 fflush(stdout);
 }
 #endif
+#endif
 
 	    PC += 2;
 segrep:
@@ -2785,8 +2877,13 @@
 		case INSw:
 		case OUTSb:
 		case OUTSw:
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+		    goto not_implemented;
+#else
 		    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 		    exit(1);
+#endif
 		case MOVSw: {
 		    unsigned char *src, *dest;
 		    if (count == 0) return (PC);
@@ -2814,8 +2911,8 @@
 		    } }
 		case CMPSw: {
 		    unsigned char *src, *dest;
-		    unsigned long res, src1;
-		    long src2;
+		    unsigned long res, src1=0;
+		    long src2=0;
 		    if (count == 0) return (PC);
 		    src = ALLOW_OVERRIDE(LONG_DS) + (ESI);
 		    dest = LONG_ES + EDI;
@@ -2968,7 +3065,7 @@
 	    } }
 
 	case GRP1wrm: {
-	    DWORD src1, src2, res; unsigned char *mem_ref;
+	    DWORD src1=0, src2, res; unsigned char *mem_ref;
 	    res = (*(PC+1)>>3)& 0x7;
 	    PC += hsw_modrm_32_quad(env,PC,interp_var);
 	    mem_ref = MEM_REF;
@@ -2997,6 +3094,12 @@
 		    SETDFLAGS;
 		    } return (PC);
 		case 4: { /* MUL EAX */
+#ifdef DOSEMU
+		    u_int64_t res = (u_int64_t)EAX;
+		    res *= (u_int64_t)FETCH_EREG (mem_ref);
+		    EAX = (u_int32_t)res;
+		    EDX = (u_int32_t)(res>>32);
+#else
                     MULT resm, src1m, src2m, mulr[4];
                     src1m.longw = EAX;
                     src2m.longw = FETCH_EREG(mem_ref);
@@ -3010,12 +3113,19 @@
 		    resm.word.snjr = src1m.word.jnr;
 		    EAX = resm.longw;
 		    EDX = src2m.longw;
+#endif
 		    RES_32 = 0;
-		    if(src2m.longw) { SRC1_16 = SRC2_16 = 0x8000;
+		    if (EDX) { SRC1_16 = SRC2_16 = 0x8000;
 			CARRY = 1; }
 		    else SRC1_16 = SRC2_16 = 0;
                     } return(PC);
 		case 5: { /* IMUL EAX */
+#ifdef DOSEMU
+		    int64_t res = (int64_t)EAX;
+		    res *= (int64_t)FETCH_EREG (mem_ref);
+		    EAX = (u_int32_t)res;
+		    EDX = (u_int32_t)(res>>32);
+#else
                     MULT resm, src1m, src2m, mulr[4];
 		    int sg1=1, sg2=1;
                     src1m.longw = EAX;
@@ -3040,6 +3150,7 @@
 			EDX = ~EDX;
 			EDX += (sg1 & (~sg2))>>31; /* carry from eax */
 		    }
+#endif
 		    RES_32 = 0;
 		    if((EDX == 0) || (EDX == 0xffffffff)) { SRC1_16 = SRC2_16 = 0x8000;
 			CARRY = 1; }
@@ -3115,6 +3226,12 @@
 		    SETDFLAGS;
 		    } return (PC);
 		case 4: { /* MUL EAX */
+#ifdef DOSEMU
+		    u_int64_t res = (u_int64_t)EAX;
+		    res *= (u_int64_t)FETCH_QUAD (mem_ref);
+		    EAX = (u_int32_t)res;
+		    EDX = (u_int32_t)(res>>32);
+#else
                     MULT resm, src1m, src2m, mulr[4];
                     src1m.longw = EAX;
                     src2m.longw = FETCH_QUAD(mem_ref);
@@ -3128,12 +3245,19 @@
 		    resm.word.snjr = src1m.word.jnr;
 		    EAX = resm.longw;
 		    EDX = src2m.longw;
+#endif
 		    RES_32 = 0;
-		    if(src2m.longw) { SRC1_16 = SRC2_16 = 0x8000;
+		    if (EDX) { SRC1_16 = SRC2_16 = 0x8000;
 			CARRY = 1; }
 		    else SRC1_16 = SRC2_16 = 0;
                     } return(PC);
 		case 5: { /* IMUL EAX */
+#ifdef DOSEMU
+		    int64_t res = (int64_t)EAX;
+		    res *= (int64_t)FETCH_QUAD (mem_ref);
+		    EAX = (u_int32_t)res;
+		    EDX = (u_int32_t)(res>>32);
+#else
                     MULT resm, src1m, src2m, mulr[4];
 		    int sg1=1, sg2=1;
                     src1m.longw = EAX;
@@ -3158,6 +3282,7 @@
 			EDX = ~EDX;
 			EDX += (sg1 & (~sg2))>>31; /* carry from eax */
 		    }
+#endif
 		    RES_32 = 0;
 		    if((EDX == 0) || (EDX == 0xffffffff)) { SRC1_16 = SRC2_16 = 0x8000;
 			CARRY = 1; }
@@ -3367,10 +3492,23 @@
 
     not_implemented:
 	fprintf(stderr," 32/32 nonimplemented instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2),
-		SHORT_CS_16,PC-LONG_CS,PC);
+		SHORT_CS_16,PC-LONG_CS,(int)PC);
+#ifdef DOSEMU
+	*err = EXCP06_ILLOP; return (P0);
+#else
 	exit(1);
+#endif
+
+not_permitted:
+#ifdef DOSEMU
+	*err = EXCP0D_GPF; return P0;
+#endif
     illegal_op:
 	fprintf(stderr," 32/32 illegal instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2), 
-                SHORT_CS_16,PC-LONG_CS,PC);
+                SHORT_CS_16,PC-LONG_CS,(int)PC);
+#ifdef DOSEMU
+	*err = EXCP06_ILLOP; return (P0);
+#else
         exit(1); 
+#endif
 }
diff -urN twin-3.1.1/intp32/interp_main.c twin/intp32/interp_main.c
--- twin-3.1.1/intp32/interp_main.c	Fri Oct 24 16:46:23 1997
+++ twin/intp32/interp_main.c	Sat Nov  1 21:33:19 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*    
 	interp_main.c	1.31
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -26,24 +43,30 @@
 
 	mailto:twin@willows.com 
 
+changes for use with dosemu-0.67 1997/10/20 vignani@mbox.vol.it
  */
 
 #include <stdio.h>
 #include <math.h>
+#ifdef linux
+#include <asm/bitops.h>
+#endif
 #include "Log.h"
 #include "hsw_interp.h"
 #include "mod_rm.h"
 
-extern unsigned char *
-hsw_interp_16_32(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var);
-extern unsigned char *
-hsw_interp_32_16(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var);
-
 extern REGISTER PortIO(DWORD, DWORD, UINT, BOOL);
 extern void LogProcName(WORD, WORD, WORD);
 
 extern ENV87 hsw_env87;
 
+#ifdef DOSEMU
+BOOL vm86f = 1;
+#  define fprintf our_fprintf
+#  define our_fprintf(stream, args...) error(##args)
+#endif
+BOOL data32=0, code32=0;
+
 #ifdef DEBUG
 #include <string.h>
 char * decode(int opcode, int modrm);
@@ -58,7 +81,12 @@
 long start_count= -1;
 long end_count= -1;
 int granularity = 1;
+#ifdef DOSEMU
+unsigned long loop_PC = 0;
+extern long instr_count;
+#else
 int instr_count = 0;
+#endif
 int print_initialized = 0;
 int dbx_cs = 0;
 int dbx_ip = 0;
@@ -211,92 +239,25 @@
     FatalAppExit(0,buf);
 }
 
-/**************************************************************************
-    The interpreter is actually called with a BINADDR as its second
-    parameter, but we will re-use this register as our PC instead,
-    since that is all we really will use the passed address for
-    anyway. mfh
-**************************************************************************/
-void
-invoke_code16(Interp_ENV *env)
-
+unsigned char *
+  hsw_interp_16_16 (Interp_ENV *env, unsigned char *P0, unsigned char *PC,
+  	Interp_VAR *interp_var, int *err)
 {
-    Interp_VAR interp_variables;
-    Interp_VAR *interp_var = &interp_variables;
-    register unsigned char *PC;
-#ifdef DEBUG
-    int ifpr;
-    if (!print_initialized) {
-	char *ch;
-
-	print_initialized = 1;
-	if ( ch = getenv("HSW_START")) {
-	    if(strstr(ch,"0x") == ch)
-		sscanf(ch+2, "%x", &start_count);
-	    else
-		sscanf(ch, "%d", &start_count);
-	    printf("Starting instruction for print is: %d\n", start_count);
-	}
-	if ( ch = getenv("HSW_END")) {
-	    if(strstr(ch,"0x") == ch)
-		sscanf(ch+2, "%x", &end_count);
-	    else
-		sscanf(ch, "%d", &end_count);
-	    printf("  Ending instruction for print is: %d\n", end_count);
-	}
-	if ( ch = getenv("HSW_GRAN")) {
-	    if(strstr(ch,"0x") == ch)
-		sscanf(ch+2, "%x", &granularity);
-	    else
-		sscanf(ch, "%d", &granularity);
-	    printf("   Granularity for print is: %d\n", granularity);
-	}
-	if ( ch = getenv("HSW_SEGMENT_PRINT")) {
-	    segment_print = 1;
-	}
-	if ( ch = getenv("HSW_STACK_PRINT")) {
-	    stack_print = 1;
-	}
-	if (ch = getenv("HSW_OP32")) op32_print = 1;
-	if (ch = getenv("HSW_AD32")) ad32_print = 1;
-	if ( ch = getenv("HSW_SHORT_PRINT")) {
-	    small_print = 1;
-	}
-	if ( ch = getenv("HSW_FLOAT_PRINT")) float_print = 1;
-	if ( ch = getenv("HSW_DBX_CS")) {
-	    if(strstr(ch,"0x") == ch)
-		sscanf(ch+2, "%x", &dbx_cs);
-	    else
-		sscanf(ch, "%d", &dbx_cs);
-	    dbx_cs = dbx_cs & 0xffff;
-	    printf("dbx_stop CS value is: %04x\n", dbx_cs);
-	}
-	if ( ch = getenv("HSW_DBX_IP")) {
-	    if(strstr(ch,"0x") == ch)
-		sscanf(ch+2, "%x", &dbx_ip);
-	    else
-		sscanf(ch, "%d", &dbx_ip);
-	    dbx_ip = dbx_ip & 0xffff;
-	    printf("dbx_stop IP value is: %04x\n", dbx_ip);
-	}
-    }
+  *err = 0;
+#if defined(DOSEMU) && defined(DEBUG)
+  loop_PC = 0;
 #endif
-    SHORT_CS_16 = (unsigned int)env->trans_addr >> 16;
-
-    SET_SEGREG(LONG_CS,SHORT_CS_16);
-    SET_SEGREG(LONG_DS,SHORT_DS_16);
-    SET_SEGREG(LONG_ES,SHORT_ES_16);
-    SET_SEGREG(LONG_SS,SHORT_SS_16);
-    SET_SEGREG(LONG_FS,SHORT_FS_16);
-    SET_SEGREG(LONG_GS,SHORT_GS_16);
-    OVERRIDE = (unsigned char *)(0);
-    PC = (unsigned char *)LONG_CS + LOWORD(env->trans_addr);
-    EBP = EBP - (unsigned long)LONG_SS;
-    ESP = ESP - (unsigned long)LONG_SS;
-
-    next_switch: OVERRIDE = (unsigned char *)(0);
-    override: ;    /* single semicolon needed to attach label to */
+next_switch:
+#if defined(DOSEMU) && defined(DEBUG)
+  instr_count++;
+#endif
+  OVERRIDE = INVALID_OVR;
+  P0 = PC;
+override: ;    /* single semicolon needed to attach label to */
 #ifdef DEBUG
+#ifdef DOSEMU
+    if ((long)PC > loop_PC) { e_debug(env, P0, PC, interp_var); loop_PC = 0; }
+#else
     if((instr_count++)==start_count)print=1;
     if(instr_count==end_count)print=0;
     if (dbx_cs)
@@ -323,11 +284,16 @@
 	    printf("%04x:%04x %02x %02x %04x %04x %04x %04x %04x %04x %04x %04x %s %d\n", SHORT_CS_16, PC-(LONG_CS),*PC, *(PC+1), AX, BX, CX, DX, SI, DI, BP, SP, decode(*PC, *(PC+1)), instr_count);
 	fflush(stdout);
     }
+#endif	/* DOSEMU */
 #endif
 
     switch (*PC) {
 	case ADDbfrm: {
 	    int res, src1, src2; unsigned char *mem_ref;
+#ifdef DOSEMU
+	    /* 00 00 00 is probably invalid code... */
+	    if ((*(PC+1)==0)&&(*(PC+2)==0)) { *err=-98; return P0; }
+#endif
 	    PC += hsw_modrm_16_byte(env,PC,interp_var);
 	    src2 = *HREG1; mem_ref = MEM_REF; src1 = *mem_ref;
 	    *mem_ref = res = src1 + src2;
@@ -475,6 +441,9 @@
 			    } goto next_switch;
 			case 2: /* LLDT */ /* Privileged */
 			    /* Load Local Descriptor Table Register */
+#ifdef DOSEMU
+			    if (vm86f) goto not_permitted;
+#endif
 			    PC = PC +1 + hsw_modrm_16_word(env,PC + 1,interp_var);
 			    goto next_switch;
 			case 3: /* LTR */ {
@@ -540,10 +509,16 @@
 			    } goto next_switch;
 			case 2: /* LGDT */ /* Privileged */
 			    /* Load Global Descriptor Table Register */
+#ifdef DOSEMU
+			    if (vm86f) goto not_permitted;
+#endif
 			    PC = PC+1+hsw_modrm_16_word(env,PC + 1,interp_var);
 		goto not_implemented;
 			case 3: /* LIDT */ /* Privileged */
 			    /* Load Interrupt Descriptor Table Register */
+#ifdef DOSEMU
+			    if (vm86f) goto not_permitted;
+#endif
 			    PC = PC+1+hsw_modrm_16_word(env,PC + 1,interp_var);
 			    goto next_switch;
 			case 4: /* SMSW */ {
@@ -551,7 +526,11 @@
 			    int temp; unsigned char *mem_ref;
 			    PC += 1; PC += hsw_modrm_16_word(env,PC,interp_var);
 			    mem_ref = MEM_REF;
+#ifdef DOSEMU
+			    temp = 0x13;	/* PM, FPU */
+#else
 			    temp = 0 /* should be LIMIT field */;
+#endif
 			    if (IS_MODE_REG) *(unsigned short *)mem_ref = temp;
 			    else {PUT_WORD(mem_ref,temp);}
 			    } goto next_switch;
@@ -559,6 +538,9 @@
 			    goto illegal_op;
 			case 6: /* LMSW */ /* Privileged */
 			    /* Load Machine Status Word */
+#ifdef DOSEMU
+			    if (vm86f) goto not_permitted;
+#endif
 			    PC = PC+1+hsw_modrm_16_word(env,PC + 1,interp_var);
 		goto not_implemented;
 			case 7: /* Illegal */
@@ -600,6 +582,9 @@
 		    } goto next_switch;
 		case 0x06: /* CLTS */ /* Privileged */
 		    /* Clear Task State Register */
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+#endif
 		    PC += 2; goto next_switch;
 		case 0x08: /* INVD */
 		    /* INValiDate cache */
@@ -608,17 +593,15 @@
 		    /* Write-Back and INValiDate cache */
 		    PC += 2; goto next_switch;
 		case 0x20: /* MOVcdrd */ /* Privileged */
-		    goto not_implemented;
 		case 0x21: /* MOVddrd */ /* Privileged */
-                    goto not_implemented;
  		case 0x22: /* MOVrdcd */ /* Privileged */
-                    goto not_implemented;
 		case 0x23: /* MOVrddd */ /* Privileged */
-                    goto not_implemented;
 		case 0x24: /* MOVtdrd */ /* Privileged */
-                    goto not_implemented;
 		case 0x26: /* MOVrdtd */ /* Privileged */
-                    goto not_implemented;
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+#endif
+                     goto not_implemented;
 		case 0x80: /* JOimmdisp */
 		    if (IS_OF_SET) {
 			int temp = FETCH_WORD(PC+2);
@@ -821,6 +804,19 @@
 		    SET_SEGREG(LONG_FS,temp);
 		    SHORT_FS_32 = temp;
 		    } PC += 2; goto next_switch;
+		case 0xa2: /* CPUID */ {
+		      if (EAX==0) {
+			EAX = 1;
+			EBX = 0x756e6547;
+			ECX = 0x6c65746e;
+			EDX = 0x49656e69;
+		      }
+		      else if (EAX==1) {
+			EAX = 0x052c;
+			EBX = ECX = 0;
+			EDX = 0x1bf;
+		      }
+		    } PC += 2; goto next_switch;
                 case 0xa3: /* BT */ {
                     unsigned char *mem_ref; DWORD temp, ind1;
                     long ind;
@@ -1546,7 +1542,11 @@
 	    SRC1_16 = SRC2_16 = RES_32 = res;
 	    } PC += 3; goto next_switch;
 	case SEGes:
+#ifdef DOSEMU
+	    if (!vm86f && (SHORT_ES_16 == 0 || LONG_ES == (unsigned char *) -1)) {
+#else
 	    if (SHORT_ES_16 == 0 || LONG_ES == (unsigned char *)-1) {
+#endif
 		char outbuf[80];
 		sprintf(outbuf,
 			"General Protection Fault: CS:IP %x:%x zero ES\n",
@@ -1560,7 +1560,7 @@
 		AL += 6;
 		SET_AF
 	    } else CLEAR_AF
-	    if ((AL > 0x90) || (IS_CF_SET)) {
+	    if (((AL & 0xf0) > 0x90) || (IS_CF_SET)) {
 		AL += 0x60;
 		SET_CF;
 	    } else CLEAR_CF;
@@ -1637,7 +1637,7 @@
 		AL -= 6;
 		SET_AF
 	    } else CLEAR_AF
-	    if ((AL > 0x90) || (IS_CF_SET)) {
+	    if (((AL & 0xf0) > 0x90) || (IS_CF_SET)) {
 		AL -= 0x60;
 		SET_CF;
 	    } else CLEAR_CF;
@@ -1956,7 +1956,11 @@
 	case ARPL:
 	    PC += 1; goto next_switch;    
 	case SEGfs:
+#ifdef DOSEMU
+	    if (!vm86f && (SHORT_FS_16 == 0 || LONG_FS == (unsigned char *) -1)) {
+#else
 	    if (SHORT_FS_16 == 0 || LONG_FS == (unsigned char *)-1) {
+#endif
 		char outbuf[80];
 		sprintf(outbuf,
 			"General Protection Fault: CS:IP %x:%x zero FS\n",
@@ -1966,7 +1970,11 @@
 	    OVERRIDE = LONG_FS;
 	    PC+=1; goto override;
 	case SEGgs:
+#ifdef DOSEMU
+	    if (!vm86f && (SHORT_GS_16 == 0 || LONG_GS == (unsigned char *) -1)) {
+#else
 	    if (SHORT_GS_16 == 0 || LONG_GS == (unsigned char *)-1) {
+#endif
 		char outbuf[80];
 		sprintf(outbuf,
 			"General Protection Fault: CS:IP %x:%x zero GS\n",
@@ -1975,13 +1983,15 @@
 	    }
 	    OVERRIDE = LONG_GS;
 	    PC+=1; goto override;
-	case OPERoverride:    /* 32 bit operand, 16 bit addressing */
-	    PC = hsw_interp_32_16(env, PC+1, interp_var);
-	    /* if(PC) return; */
+	case OPERoverride:	/* 0x66: 32 bit operand, 16 bit addressing */
+	    if (data32) return (PC+1);
+	    PC = hsw_interp_32_16 (env, P0, PC+1, interp_var, err);
+	    if (*err) return P0;
 	    goto next_switch;
-	case ADDRoverride:    /* 16 bit operand, 32 bit addressing */
-	    PC = hsw_interp_16_32(env, PC+1, interp_var);
-	    /* if(PC) return; */
+	case ADDRoverride:	/* 0x67: 16 bit operand, 32 bit addressing */
+	    if (code32) return (PC+1);
+	    PC = hsw_interp_16_32 (env, P0, PC+1, interp_var, err);
+	    if (*err) return P0;
 	    goto next_switch;
 	case PUSHwi: {
 	    unsigned char *sp = LONG_SS + SP;
@@ -2025,10 +2035,13 @@
 	    SRC1_16 = SRC2_16 = 0;
 	    RES_32 = ((res==0)||(res==0xffffffff))?0:-1;
 	    } goto next_switch; 
-	case INSb:	/* NOT IMPLEMENTED !!!!!! */
-	case INSw:	/* NOT IMPLEMENTED !!!!!! */
-	case OUTSb:	/* NOT IMPLEMENTED !!!!!! */
-	case OUTSw:	/* NOT IMPLEMENTED !!!!!! */
+	case INSb:
+	case INSw:
+	case OUTSb:
+	case OUTSw:
+#ifdef DOSEMU
+	    if (vm86f) goto not_permitted;
+#endif
             goto not_implemented;
 	case JO: if (IS_OF_SET) {
 	    JUMP(PC+1); goto next_switch; 
@@ -3598,7 +3611,7 @@
 		}
 	    }}
 	case LEA: {
-	    int temp, modrm;
+	    int temp=0, modrm;
 	    modrm = *(PC+1);
 	    switch (modrm >> 6) {
 		case 0:
@@ -3757,13 +3770,21 @@
 	    ip = (FETCH_WORD(PC+1) & 0xffff);
 	    cs = FETCH_WORD(PC+3);
 	    transfer_magic = (WORD)GetSelectorType(cs);
+#ifdef DOSEMU
+	    if (vm86f || (transfer_magic == TRANSFER_CODE16)) {
+#else
 	    if (transfer_magic == TRANSFER_CODE16) {
+#endif
 		SHORT_CS_16 = cs;
 		SET_SEGREG(LONG_CS,cs);
 		PC = ip + LONG_CS;
 		goto next_switch;
 	    }
+#ifdef DOSEMU
+	    if (vm86f || (transfer_magic == TRANSFER_CALLBACK) || 
+#else
 	    if ((transfer_magic == TRANSFER_CALLBACK) || 
+#endif
 	    		(transfer_magic == TRANSFER_BINARY))  {
 		LONGPROC conv,targ;
 		SEGIMAGE *lpSegImage = &((SEGIMAGE *)
@@ -3773,7 +3794,11 @@
 		EBP = (long)LONG_SS + EBP;
 		ESP = (long)LONG_SS + ESP;
 		trans_interp_flags(env, interp_var);    
+#ifdef DOSEMU
+		if (vm86f||(transfer_magic == TRANSFER_CALLBACK)) {
+#else
 		if (transfer_magic == TRANSFER_CALLBACK) {
+#endif
 		    env->trans_addr = (BINADDR)MAKELONG(ip,cs);
 #ifdef	TRACE
 		LogProcName(cs,ip,1);
@@ -3784,7 +3809,7 @@
 			env->return_addr >> 16,
 			(env->return_addr & 0xffff)-5));
 #endif
-#endif
+#endif	/* TRACE */
 		}
 #ifdef DEBUG
 		else    /* TRANSFER_BINARY */
@@ -3809,10 +3834,12 @@
 	    if (transfer_magic == TRANSFER_RETURN) {
 		SHORT_CS_16 = cs;
 		env->return_addr = (cs << 16) | ip;
+#ifndef DOSEMU
 		trans_interp_flags(env, interp_var);    
 		EBP = EBP + (long)LONG_SS;
 		ESP = ESP + (long)LONG_SS;
-		return;
+#endif
+		return PC;
 	    }
 	    invoke_data(env);    /* TRANSFER_DATA or garbage */
         }
@@ -3820,11 +3847,19 @@
 	    PC += 1; goto next_switch;
 	case PUSHF: {
 	    unsigned int temp;
+#ifdef DOSEMU
+	    if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK))
+		goto not_permitted;
+#endif
 	    temp =     trans_interp_flags(env, interp_var);    
 	    PUSHWORD(temp);
 	    } PC += 1; goto next_switch;
 	case POPF: {
 	    unsigned int temp;
+#ifdef DOSEMU
+	    if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK))
+		goto not_permitted;
+#endif
 	    POPWORD(temp);
 	    trans_flags_to_interp(env, interp_var, temp);
 	    } PC += 1; goto next_switch;
@@ -4256,7 +4291,7 @@
 	    PC += hsw_modrm_16_byte(env,PC,interp_var);
 	    *MEM_REF = *PC; PC += 1; goto next_switch;
 	case MOVwirm: {
-	    int temp; unsigned char *mem_ref;
+	    /*int temp;*/ unsigned char *mem_ref;
 	    PC += hsw_modrm_16_word(env,PC,interp_var);
 	    mem_ref = MEM_REF;
 	    if (IS_MODE_REG) {
@@ -4274,13 +4309,13 @@
 	    bp = LONG_SS + BP;
 	    ss = LONG_SS;
 	    temp = bp - ss;
-	    *(sp-2) = temp; *(sp-1) = temp >> 8;
 	    sp -= 2;
+	    *sp = temp; *(sp+1) = temp >> 8;
 	    temp = sp - ss;
 	    if (level) {
 		while (level--) {
-		    *(sp-2) = *(bp-2); *(sp-1) = *(bp-1);
 		    bp -= 2; sp -= 2;
+		    *sp = *bp; *(sp+1) = *(bp+1);
 		}
 		*(sp - 2) = temp; *(sp - 1) = temp >> 8;
 	    }
@@ -4307,10 +4342,12 @@
 		goto next_switch;
 	    } else {
 		env->return_addr = ip | (cs << 16);
+#ifndef DOSEMU
 		trans_interp_flags(env, interp_var);
 		EBP = EBP + (long)LONG_SS;
 		ESP = ESP + (long)LONG_SS;
-		return;
+#endif
+		return PC;
 	    }
 	    }
 	case RETl: {
@@ -4326,17 +4363,26 @@
 		goto next_switch;
 	    } else {
 		env->return_addr = ip | (cs << 16);
+#ifndef DOSEMU
 		trans_interp_flags(env, interp_var);
 		EBP = EBP + (long)LONG_SS;
 		ESP = ESP + (long)LONG_SS;
-		return;
+#endif
+		return PC;
 	    }
 	    } 
 	case INT3:
+#ifdef DOSEMU
+	    *err=EXCP03_INT3; return P0;
+#else
 	    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 	    PC += 1; goto next_switch;
-	case INT: {
-	    unsigned int temp, cs, ip = (unsigned int)(PC - LONG_CS);
+#endif
+	case INT:
+#ifdef DOSEMU
+	    *err=EXCP0D_GPF; return P0;
+#else
+	    { unsigned int temp, cs, ip = (unsigned int)(PC - LONG_CS);
 	    PUSHWORD(ip);
 	    cs = SHORT_CS_16;
 	    PUSHWORD(cs);
@@ -4350,10 +4396,20 @@
 	    ESP = ESP - (long)LONG_SS;
 	    trans_flags_to_interp(env, interp_var, env->flags);
 	    } PC += 2; goto next_switch;
+#endif
 	case INTO:
+#ifdef DOSEMU
+	    *err=EXCP04_INTO; return P0;
+#else
 	    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 	    PC += 1; goto next_switch;
-	case IRET: {
+#endif
+	case IRET:
+#ifdef DOSEMU
+	    if (vm86f) goto not_permitted;
+	    else
+#endif
+	    {
 	    unsigned int cs, ip, flags;
 	    unsigned char *sp = LONG_SS + SP;
 	    ip = *(sp) | (*(sp + 1) >> 8);
@@ -4368,10 +4424,12 @@
 		goto next_switch;
 	    } else {
 		env->return_addr = ip | (cs << 16);
+#ifndef DOSEMU
 		trans_interp_flags(env, interp_var);
 		EBP = EBP + (long)LONG_SS;
 		ESP = ESP + (long)LONG_SS;
-		return;
+#endif
+		return PC;
 	    }
 	    } 
 	case SHIFTb: {
@@ -4821,7 +4879,18 @@
    case ESC5:
    case ESC6:
    case ESC7:
-
+   { int ifpr;
+#ifdef DOSEMU
+	e_printf("%04x:%04x %02x %02x %04x %04x %04x %04x %04x %04x %04x %04x %s %ld\n",
+		SHORT_CS_16, PC - (LONG_CS), *PC, *(PC + 1), AX, BX, CX, DX, SI, DI, BP, SP, decode (*PC, *(PC + 1)), instr_count);
+	for (ifpr = 0; ifpr < 4; ifpr++)
+	  e_printf(" %18.8g ", hsw_env87.fpregs[ifpr]);
+	e_printf("\n");
+	for (ifpr = 4; ifpr < 8; ifpr++)
+	  e_printf(" %18.8g ", hsw_env87.fpregs[ifpr]);
+	e_printf("\n");
+	e_printf(" sw cw tag %4x %4x %4x\n", hsw_env87.fpus, hsw_env87.fpuc, hsw_env87.fpstt);
+#else
     if(float_print){
             /*      address   opcode     ax   bx   cx   dx   si   di  bp  sp*/
             if(!(print && (!(instr_count % granularity))))printf("%04x:%04x %02x %02x %04x %04x %04x %04x %04x %04x %04x %04x %s %d\n", SHORT_CS_16, PC-(LONG_CS),*PC, *(PC+1), AX, BX, CX, DX, SI, DI, BP, SP, decode(*PC, *(PC+1)), instr_count);
@@ -4830,10 +4899,10 @@
 	printf(" sw cw tag %4x %4x %4x\n",hsw_env87.fpus,hsw_env87.fpuc,hsw_env87.fpstt);
         fflush(stdout);
     }
-
-
-   switch(*PC){
 #endif
+   }
+   switch(*PC){
+#endif	/* DEBUG */
 	case ESC0: {
 	    int reg = (*(PC+1) & 7);
 	    unsigned int funct = (unsigned int)(*(PC+1) & 0x38) >> 3;
@@ -4895,14 +4964,23 @@
 #endif
 	case LOOPNZ_LOOPNE: 
 	    if ((--CX != 0) && (!IS_ZF_SET)) {
+#if defined(DOSEMU) && defined(DEBUG)
+		loop_PC = (long)PC;
+#endif
 		JUMP((PC+1)); goto next_switch;
 	    } PC += 2; goto next_switch;
 	case LOOPZ_LOOPE: 
 	    if ((--CX != 0) && (IS_ZF_SET)) {
+#if defined(DOSEMU) && defined(DEBUG)
+		loop_PC = (long)PC;
+#endif
 		JUMP((PC+1)); goto next_switch;
 	    } PC += 2; goto next_switch;
 	case LOOP: 
 	    if (--CX != 0) {
+#if defined(DOSEMU) && defined(DEBUG)
+		loop_PC = (long)PC;
+#endif
 		JUMP((PC+1)); goto next_switch;
 	    } PC += 2; goto next_switch;
 	case JCXZ: 
@@ -4910,39 +4988,93 @@
 		JUMP((PC+1)); goto next_switch;
 	    } PC += 2; goto next_switch;
 
-	case INb:
-	    AL = PortIO((DWORD)*(++PC), 0, 8, FALSE);
-	    goto next_switch;
-	case INw:
-	    AX = PortIO((DWORD)*(++PC), 0, 16, FALSE);
-	    goto next_switch;
-	case OUTb:
-	    PortIO((DWORD)*(++PC), AL, 8, TRUE);
-	    goto next_switch;
-	case OUTw:
-	    PortIO((DWORD)*(++PC), AX, 16, TRUE);
-	    goto next_switch;
-	case INvb:
-	    AL = PortIO(DX, 0, 8, FALSE);
-	    goto next_switch;
-	case INvw:
-	    AX = PortIO(DX, 0, 16, FALSE);
-	    goto next_switch;
-	case OUTvb:
-	    PortIO(DX, AL, 8, TRUE);
-	    goto next_switch;
-	case OUTvw:
-	    PortIO(DX, AX, 16, TRUE);
+	case INb: {
+#ifdef DOSEMU
+	      DWORD a = *(PC+1);
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if (!test_bit(a, io_bitmap)) goto not_permitted;
+	      }
+#endif
+	      AL = PortIO((DWORD)*(++PC), 0, 8, FALSE);
+	    }
+	    goto io_switch;
+	case INw: {
+#ifdef DOSEMU
+	      DWORD a = *(PC+1);
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((a&1)||(!test_bit(a+1, io_bitmap))) goto not_permitted;
+	      }
+#endif
+	      AX = PortIO((DWORD)*(++PC), 0, 16, FALSE);
+	    }
+	    goto io_switch;
+	case OUTb: {
+#ifdef DOSEMU
+	      DWORD a = *(PC+1);
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if (!test_bit(a, io_bitmap)) goto not_permitted;
+	      }
+#endif
+	      PortIO((DWORD)*(++PC), AL, 8, TRUE);
+	    }
+	    goto io_switch;
+	case OUTw: {
+#ifdef DOSEMU
+	      DWORD a = *(PC+1);
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((a&1)||(!test_bit(a+1, io_bitmap))) goto not_permitted;
+	      }
+#endif
+	      PortIO((DWORD)*(++PC), AX, 16, TRUE);
+	    }
+	    goto io_switch;
+	case INvb: {
+#ifdef DOSEMU
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((DX>0x3ff)||(!test_bit(DX, io_bitmap))) goto not_permitted;
+	      }
+#endif
+	      AL = PortIO(DX, 0, 8, FALSE);
+	    }
+	    goto io_switch;
+	case INvw: {
+#ifdef DOSEMU
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((DX>0x3ff)||(DX&1)||(!test_bit(DX+1, io_bitmap))) goto not_permitted;
+	      }
+#endif
+	      AX = PortIO(DX, 0, 16, FALSE);
+	    }
+	    goto io_switch;
+	case OUTvb: {
+#ifdef DOSEMU
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((DX>0x3ff)||(!test_bit(DX, io_bitmap))) goto not_permitted;
+	      }
+#endif
+	      PortIO(DX, AL, 8, TRUE);
+	    }
+	    goto io_switch;
+	case OUTvw: {
+#ifdef DOSEMU
+	      if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK)) {
+		if ((DX>0x3ff)||(DX&1)||(!test_bit(DX+1, io_bitmap))) goto not_permitted;
+	      }
+#endif
+	      PortIO(DX, AX, 16, TRUE);
+	    }
+io_switch:
+	    PC += 1;
 	    goto next_switch;
 
 	case CALLd: {
 	    unsigned int ip = PC - LONG_CS + 3;
 	    PUSHWORD(ip);
-	    PC = LONG_CS + (ip + (signed short)(FETCH_WORD((PC+1)))&0xffff);
+	    PC = LONG_CS + ((ip + (signed short)FETCH_WORD((PC+1))) & 0xffff);
 	    } goto next_switch;
 	case JMPd: {
 	    unsigned int ip = PC - LONG_CS + 3;
-	    PC = LONG_CS + (ip + (signed short)(FETCH_WORD((PC+1)))&0xffff);
+	    PC = LONG_CS + ((ip + (signed short)FETCH_WORD((PC+1))) & 0xffff);
 	    } goto next_switch;
 	case JMPld: {
 	    unsigned int cs, ip;
@@ -4951,13 +5083,21 @@
 	    cs = (FETCH_WORD(PC+3) & 0xffff);
 	    SHORT_CS_16 = cs;
 	    transfer_magic = (WORD)GetSelectorType(cs);
+#ifdef DOSEMU
+	    if (vm86f || (transfer_magic == TRANSFER_CODE16)) {
+#else
 	    if (transfer_magic == TRANSFER_CODE16) {
+#endif
 		SHORT_CS_16 = cs;
 		SET_SEGREG(LONG_CS,cs);
 		PC = ip + LONG_CS;
 		goto next_switch;
 	    }
+#ifdef DOSEMU
+	    if (vm86f || (transfer_magic == TRANSFER_CALLBACK) || 
+#else
 	    if ((transfer_magic == TRANSFER_CALLBACK) || 
+#endif
 	    		(transfer_magic == TRANSFER_BINARY))  {
 		LONGPROC conv,targ;
 		SEGIMAGE *lpSegImage = &((SEGIMAGE *)
@@ -4967,20 +5107,28 @@
 		EBP = (long)LONG_SS + EBP;
 		ESP = (long)LONG_SS + ESP;
 		trans_interp_flags(env, interp_var);   
+#ifdef DOSEMU
+		if (vm86f||(transfer_magic == TRANSFER_CALLBACK))
+#else
 		if (transfer_magic == TRANSFER_CALLBACK)
+#endif
 		    env->trans_addr = (BINADDR)MAKELONG(ip,cs);
 #ifdef	TRACE
 		LogProcName(cs,ip,1);
 #else
 #ifdef DEBUG
+#ifdef DOSEMU
+		if (vm86f||(transfer_magic == TRANSFER_CALLBACK))
+#else
 		if (transfer_magic == TRANSFER_CALLBACK)
+#endif
 		    LOGSTR((LF_DEBUG,
 			    "do_ext: jump to %s\n", GetProcName(cs,ip>>3)));
 		else    /* TRANSFER_BINARY */
 		    LOGSTR((LF_DEBUG,
 			    "do_ext: jumping to binary thunk %x:%x\n",cs,ip));
 #endif
-#endif
+#endif	/* TRACE */
 		(conv)(env,targ);
 #ifdef	TRACE
 		LogProcName(AX,DX,0);
@@ -4998,10 +5146,12 @@
 	    }
 	    if (transfer_magic == TRANSFER_RETURN) {
 		env->return_addr = (cs << 16) | ip;
+#ifndef DOSEMU
 		trans_interp_flags(env, interp_var);
 		EBP = EBP + (long)LONG_SS;
 		ESP = ESP + (long)LONG_SS;
-		return;
+#endif
+		return PC;
 	    }
 	    invoke_data(env);    /* TRANSFER_DATA or garbage */
 	}
@@ -5010,12 +5160,14 @@
 	case LOCK:
 	    PC += 1; goto next_switch;
 	case 0xf1:    /* illegal on 8086 and 80x86 */
-	    fprintf(stderr,illegal_msg,PC,SHORT_CS_16,PC-LONG_CS);
-	    exit(1);
+	    goto illegal_op;
 	case REPNE: {
 	    int count = CX;
 
 #ifdef DEBUG
+#ifdef DOSEMU
+	instr_count += count;
+#else
 if((instr_count++)==start_count)print=1;
 if(instr_count==end_count)print=0;
     if(print && (!(instr_count % granularity))){
@@ -5036,7 +5188,8 @@
 printf("%04x:%04x %02x %02x %04x %04x %04x %04x %04x %04x %04x %04x %s %d\n", SHORT_CS_16, PC-(LONG_CS)+1,*(PC+1), *(PC+2), AX, BX, CX, DX, SI, DI, BP, SP, decode(*(PC+1), *(PC+2)), instr_count);
 fflush(stdout);
 }
-#endif
+#endif	/* DOSEMU */
+#endif	/* DEBUG */
 
 	    PC += 2;
 segrepne:
@@ -5045,8 +5198,13 @@
 		case INSw:
 		case OUTSb:
 		case OUTSw:
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+		    goto not_implemented;
+#else
 		    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 		    exit(1);
+#endif
 		case MOVSb: {
 		    unsigned char *src, *dest;
 		    if (count == 0) goto next_switch;
@@ -5084,7 +5242,7 @@
 		    } }
 		case CMPSb: {
 		    unsigned char *src, *dest;
-		    unsigned int res, src1, src2;
+		    unsigned int res, src1=0, src2=0;
 		    if (count == 0) goto next_switch;
 		    src = ALLOW_OVERRIDE(LONG_DS) + (SI);
 		    dest = LONG_ES + DI;
@@ -5130,8 +5288,8 @@
 		    } goto next_switch;
 		case CMPSw: {
 		    unsigned char *src, *dest;
-		    unsigned int res, src1;
-		    int src2;
+		    unsigned int res, src1=0;
+		    int src2=0;
 		    if (count == 0) goto next_switch;
 		    src = ALLOW_OVERRIDE(LONG_DS) + (SI);
 		    dest = LONG_ES + DI;
@@ -5363,6 +5521,9 @@
 	    int count = CX;
 
 #ifdef DEBUG
+#ifdef DOSEMU
+	instr_count += count;
+#else
 if((instr_count++)==start_count)print=1;
 if(instr_count==end_count)print=0;
     if(print && (!(instr_count % granularity))){
@@ -5383,7 +5544,8 @@
 printf("%04x:%04x %02x %02x %04x %04x %04x %04x %04x %04x %04x %04x %s %d\n", SHORT_CS_16, PC-(LONG_CS)+1,*(PC+1), *(PC+2), AX, BX, CX, DX, SI, DI, BP, SP, decode(*(PC+1), *(PC+2)), instr_count);
 fflush(stdout);
 }
-#endif
+#endif	/* DOSEMU */
+#endif	/* DEBUG */
 
 	    PC += 2;
 segrep:
@@ -5392,8 +5554,13 @@
 		case INSw:
 		case OUTSb:
 		case OUTSw:
+#ifdef DOSEMU
+		    if (vm86f) goto not_permitted;
+		    goto not_implemented;
+#else
 		    fprintf(stderr,unsupp_msg,*PC,SHORT_CS_16,PC-LONG_CS);
 		    exit(1);
+#endif
 		case MOVSb: {
 		    unsigned char *src, *dest;
 		    if (count == 0) goto next_switch;
@@ -5431,7 +5598,7 @@
 		    } }
 		case CMPSb: {
 		    unsigned char *src, *dest;
-		    unsigned int res, src1, src2;
+		    unsigned int res, src1=0, src2=0;
 		    if (count == 0) goto next_switch;
 		    src = ALLOW_OVERRIDE(LONG_DS) + (SI);
 		    dest = LONG_ES + DI;
@@ -5477,8 +5644,8 @@
 		    } goto next_switch;
 		case CMPSw: {
 		    unsigned char *src, *dest;
-		    unsigned int res, src1;
-		    int src2;
+		    unsigned int res, src1=0;
+		    int src2=0;
 		    if (count == 0) goto next_switch;
 		    src = ALLOW_OVERRIDE(LONG_DS) + (SI);
 		    dest = LONG_ES + DI;
@@ -5705,9 +5872,13 @@
 	    } }
 
 	case HLT:
+#ifdef DOSEMU
+	    goto not_permitted;
+#else
 	    EBP = EBP + (long)LONG_SS;
 	    ESP = ESP + (long)LONG_SS;
-	    return;
+	    return PC;
+#endif
 	case CMC:
 	    interp_var->flags_czsp.word16.carry ^= CARRY_FLAG;
 	    PC += 1; goto next_switch;
@@ -5894,9 +6065,18 @@
 	    SET_CF;
 	    PC += 1; goto next_switch;
 	case CLI:
-	 /* CLEAR_IF; */
+#ifdef DOSEMU
+	    if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK))
+		goto not_permitted;
+	    env->flags &= ~INTERRUPT_FLAG;
+#endif
+	    PC += 1; goto next_switch;
 	case STI:
-	 /* SET_IF; */
+#ifdef DOSEMU
+	    if (vm86f && ((env->flags&IOPL_FLAG_MASK)<IOPL_FLAG_MASK))
+		goto not_permitted;
+	    env->flags |= INTERRUPT_FLAG;
+#endif
 	    PC += 1; goto next_switch;
 	case CLD:
 	    CLEAR_DF;
@@ -5992,13 +6172,21 @@
 		    ip = FETCH_WORD(mem_ref);
 		    cs = FETCH_WORD(mem_ref+2);
 		    transfer_magic = (WORD)GetSelectorType(cs);
+#ifdef DOSEMU
+		    if (vm86f||(transfer_magic == TRANSFER_CODE16)) {
+#else
 		    if (transfer_magic == TRANSFER_CODE16) {
+#endif
 			SHORT_CS_16 = cs;
 			SET_SEGREG(LONG_CS,cs);
 			PC = ip + LONG_CS;
 			goto next_switch;
 		    }
+#ifdef DOSEMU
+		    if (vm86f || (transfer_magic == TRANSFER_CALLBACK) ||
+#else
 		    if ((transfer_magic == TRANSFER_CALLBACK) ||
+#endif
 				(transfer_magic == TRANSFER_BINARY))  {
 			LONGPROC conv,targ;
 			SEGIMAGE *lpSegImage = &((SEGIMAGE *)
@@ -6008,20 +6196,28 @@
 			trans_interp_flags(env, interp_var);    
 			targ = (LONGPROC)lpSegImage->targ;
 			conv = (LONGPROC)lpSegImage->conv;
+#ifdef DOSEMU
+			if (vm86f||(transfer_magic == TRANSFER_CALLBACK))
+#else
 			if (transfer_magic == TRANSFER_CALLBACK)
+#endif
 		    	    env->trans_addr = (BINADDR)MAKELONG(ip,cs);
 #ifdef	TRACE
 			LogProcName(cs,ip,1);
 #else
 #ifdef DEBUG
+#ifdef DOSEMU
+			if (vm86f||(transfer_magic == TRANSFER_CALLBACK))
+#else
 			if (transfer_magic == TRANSFER_CALLBACK)
+#endif
 			    LOGSTR((LF_DEBUG,"do_ext: %s\n", 
 						GetProcName(cs,ip>>3)));
 			else    /* TRANSFER_BINARY */
 			    LOGSTR((LF_DEBUG,
 				"do_ext: calling binary thunk %x:%x\n",cs,ip));
 #endif
-#endif
+#endif	/* TRACE */
 			(conv)(env,targ);
 #ifdef	TRACE
 			LogProcName(AX,DX,0);
@@ -6037,13 +6233,19 @@
 			trans_flags_to_interp(env, interp_var, env->flags);
 			PC = LONG_CS + ip; goto next_switch;
 		    }
+#ifdef DOSEMU
+		    if (vm86f||(transfer_magic == TRANSFER_RETURN)) {
+#else
 		    if (transfer_magic == TRANSFER_RETURN) {
+#endif
 			SHORT_CS_16 = cs;
 			env->return_addr = (cs << 16) | ip;
+#ifndef DOSEMU
 			trans_interp_flags(env, interp_var);    
 			EBP = EBP + (long)LONG_SS;
 			ESP = ESP + (long)LONG_SS;
-			return;
+#endif
+			return PC;
 		    }
 		    invoke_data(env);    /* TRANSFER_DATA or garbage */
 		}
@@ -6062,17 +6264,30 @@
 
     not_implemented:
 	fprintf(stderr," nonimplemented instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2),
-		SHORT_CS_16,PC-LONG_CS,PC);
+		SHORT_CS_16,PC-LONG_CS,(int)PC);
+#ifdef DOSEMU
+	*err=EXCP06_ILLOP; return P0;
+#else
 	exit(1);
+#endif
+
+    not_permitted:
+#ifdef DOSEMU
+	*err=EXCP0D_GPF; return P0;
+#endif
     illegal_op:
 	fprintf(stderr," illegal instruction %2x %2x %2x at %4x:%4x long PC %x\n",*PC,*(PC+1),*(PC+2), 
-                SHORT_CS_16,PC-LONG_CS,PC);
+                SHORT_CS_16,PC-LONG_CS,(int)PC);
+#ifdef DOSEMU
+	*err=EXCP06_ILLOP; return P0;
+#else
         exit(1); 
     next_switch_16_32:;    /* 16 bit operand, 32 bit addressing switch */
     /* we only want to handle the mod/rm instructions in this switch */
     switch (*PC) {
 	default: goto next_switch;
     } /* end of the switch statement */
+#endif
 
     log_rot: { /* logical rotation don't change SF ZF AF PF flags */
 	DWORD flags;
@@ -6083,6 +6298,7 @@
 	else flags &= ~OVERFLOW_FLAG;
 	trans_flags_to_interp(env,interp_var, flags);
 	} goto next_switch;
+#ifndef DOSEMU
     next_switch_32_16:;    /* 32 bit operand, 16 bit addressing switch */
     /* only handle the "word" size intructions in this switch */
     switch (*PC) {
@@ -6094,15 +6310,142 @@
     switch (*PC) {
 	default: goto next_switch_32_16;
     } /* end of the switch statement */
+#endif
 }
 
+
+/**************************************************************************
+    The interpreter is actually called with a BINADDR as its second
+    parameter, but we will re-use this register as our PC instead,
+    since that is all we really will use the passed address for
+    anyway. mfh
+**************************************************************************/
+#ifdef DOSEMU
+
+int
+invoke_code16 (Interp_ENV *env, int vf)
+{
+  Interp_VAR interp_variables;
+  Interp_VAR *interp_var = &interp_variables;
+  unsigned char *PC;
+  int err = 0;
+
+  vm86f = (vf!=0);
+  code32 = data32 = 0;
+  SHORT_CS_16 = (unsigned int) env->trans_addr >> 16;
+
+  SET_SEGREG (LONG_CS, SHORT_CS_16);
+  SET_SEGREG (LONG_DS, SHORT_DS_16);
+  SET_SEGREG (LONG_ES, SHORT_ES_16);
+  SET_SEGREG (LONG_SS, SHORT_SS_16);
+  SET_SEGREG (LONG_FS, SHORT_FS_16);
+  SET_SEGREG (LONG_GS, SHORT_GS_16);
+  OVERRIDE = INVALID_OVR;
+  PC = (unsigned char *) LONG_CS + LOWORD (env->trans_addr);
+  trans_flags_to_interp (env, interp_var, env->flags);
+
+  PC = hsw_interp_16_16 (env, PC, PC, interp_var, &err);
+
+  if (err) env->return_addr = (SHORT_CS_16 << 16) | (PC-LONG_CS);
+  trans_interp_flags (env, interp_var);
+  return err;
+}
+
+#else	/* !DOSEMU */
+
+void
+invoke_code16(Interp_ENV *env)
+{
+    Interp_VAR interp_variables;
+    Interp_VAR *interp_var = &interp_variables;
+    unsigned char *PC;
+    int err = 0;
+#ifdef DEBUG
+    if (!print_initialized) {
+	char *ch;
+
+	print_initialized = 1;
+	if ( ch = getenv("HSW_START")) {
+	    if(strstr(ch,"0x") == ch)
+		sscanf(ch+2, "%x", &start_count);
+	    else
+		sscanf(ch, "%d", &start_count);
+	    printf("Starting instruction for print is: %d\n", start_count);
+	}
+	if ( ch = getenv("HSW_END")) {
+	    if(strstr(ch,"0x") == ch)
+		sscanf(ch+2, "%x", &end_count);
+	    else
+		sscanf(ch, "%d", &end_count);
+	    printf("  Ending instruction for print is: %d\n", end_count);
+	}
+	if ( ch = getenv("HSW_GRAN")) {
+	    if(strstr(ch,"0x") == ch)
+		sscanf(ch+2, "%x", &granularity);
+	    else
+		sscanf(ch, "%d", &granularity);
+	    printf("   Granularity for print is: %d\n", granularity);
+	}
+	if ( ch = getenv("HSW_SEGMENT_PRINT")) {
+	    segment_print = 1;
+	}
+	if ( ch = getenv("HSW_STACK_PRINT")) {
+	    stack_print = 1;
+	}
+	if (ch = getenv("HSW_OP32")) op32_print = 1;
+	if (ch = getenv("HSW_AD32")) ad32_print = 1;
+	if ( ch = getenv("HSW_SHORT_PRINT")) {
+	    small_print = 1;
+	}
+	if ( ch = getenv("HSW_FLOAT_PRINT")) float_print = 1;
+	if ( ch = getenv("HSW_DBX_CS")) {
+	    if(strstr(ch,"0x") == ch)
+		sscanf(ch+2, "%x", &dbx_cs);
+	    else
+		sscanf(ch, "%d", &dbx_cs);
+	    dbx_cs = dbx_cs & 0xffff;
+	    printf("dbx_stop CS value is: %04x\n", dbx_cs);
+	}
+	if ( ch = getenv("HSW_DBX_IP")) {
+	    if(strstr(ch,"0x") == ch)
+		sscanf(ch+2, "%x", &dbx_ip);
+	    else
+		sscanf(ch, "%d", &dbx_ip);
+	    dbx_ip = dbx_ip & 0xffff;
+	    printf("dbx_stop IP value is: %04x\n", dbx_ip);
+	}
+    }
+#endif
+    code32 = data32 = 0;
+    SHORT_CS_16 = (unsigned int)env->trans_addr >> 16;
+
+    SET_SEGREG(LONG_CS,SHORT_CS_16);
+    SET_SEGREG(LONG_DS,SHORT_DS_16);
+    SET_SEGREG(LONG_ES,SHORT_ES_16);
+    SET_SEGREG(LONG_SS,SHORT_SS_16);
+    SET_SEGREG(LONG_FS,SHORT_FS_16);
+    SET_SEGREG(LONG_GS,SHORT_GS_16);
+    OVERRIDE = INVALID_OVR;
+    PC = (unsigned char *)LONG_CS + LOWORD(env->trans_addr);
+    EBP = EBP - (unsigned long)LONG_SS;
+    ESP = ESP - (unsigned long)LONG_SS;
+
+    PC = hsw_interp_16_16 (env, PC, PC, interp_var, &err);
+}
+
+#endif	/* DOSEMU */
+
 unsigned int
 trans_interp_flags(Interp_ENV *env, Interp_VAR *interp_var)
 {
     unsigned int flags;
 
     /* turn off flag bits that we update here */
+#ifdef DOSEMU
+    flags = env->flags & 0x3f7700;
+#else
     flags = env->flags & (DIRECTION_FLAG | INTERRUPT_FLAG);
+#endif
 
     /* byte operation */
     flags |= ((BYTE_FLAG == BYTE_OP)? BYTE_FL:0);
@@ -6178,6 +6521,7 @@
 	}
 }
 
+#ifndef DOSEMU
 void print_table()
 {
     int i,j;
@@ -6198,6 +6542,7 @@
 	printf("\n\n");
     }
 }
+#endif
 
 #ifdef DEBUG
 char *inst[256] = {
diff -urN twin-3.1.1/intp32/interp_modrm.c twin/intp32/interp_modrm.c
--- twin-3.1.1/intp32/interp_modrm.c	Fri Oct 24 16:46:23 1997
+++ twin/intp32/interp_modrm.c	Sat Nov  1 21:35:32 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*    
 	interp_modrm.c	1.4
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -26,6 +43,7 @@
 
 	mailto:twin@willows.com 
 
+changes for use with dosemu-0.67 1997/10/20 vignani@mbox.vol.it
  */
 
 #include "hsw_interp.h"
@@ -292,12 +310,25 @@
 		case 254: return (ESI + (EDI << 3));
 		case 255: return (EDI + (EDI << 3));
 	}
+	return 0;	/* because of gcc warning */
 }
 
 
+#if defined(DOSEMU) && defined(DEBUG)
+  #define return(x) ret=(x);break
+  #define DEBUG_ENTRY int ret=0;
+  #define DEBUG_EXIT(args...) \
+	if (!IS_MODE_REG && TRACE_HIGH && (d.emu>2)) e_printf(##args); \
+	return ret  /* NOTE: use 'return xx', _not_ 'return(xx)' !!! */
+#else
+  #define DEBUG_ENTRY
+  #define DEBUG_EXIT(args...) return 0
+#endif
+
 int
 hsw_modrm_16_byte(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var)
 {
+	DEBUG_ENTRY
 	switch(*(PC+1)) {
 		case MOD_AL_BXSI: 
 			MEM_REF = ALLOW_OVERRIDE(LONG_DS)+((BX+SI)&0xffff);
@@ -1324,12 +1355,14 @@
 			interp_var->reg1 = &(BH);
 			IS_MODE_REG = 1; return(2);
 	}
+	DEBUG_EXIT("------- ref [%p]=%02x\n",MEM_REF,*((unsigned char *)MEM_REF));
 }
 
 
 int
 hsw_modrm_16_word(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var)
 {
+	DEBUG_ENTRY
 	switch(*(PC+1)) {
 		case MOD_AX_BXSI: 
 			MEM_REF = ALLOW_OVERRIDE(LONG_DS)+((BX+SI)&0xffff);
@@ -2356,12 +2389,14 @@
 			interp_var->reg1 = (unsigned char *)&(DI);
 			IS_MODE_REG = 1; return(2);
 	}
+	DEBUG_EXIT("------- ref [%p]=%04x\n",MEM_REF,*((unsigned short *)MEM_REF));
 }
 
 
 int
 hsw_modrm_16_quad(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var)
 {
+	DEBUG_ENTRY
 	switch(*(PC+1)) {
 		case MOD_AX_BXSI: 
 			MEM_REF = ALLOW_OVERRIDE(LONG_DS)+((BX+SI)&0xffff);
@@ -3388,12 +3423,14 @@
 			interp_var->reg1 = (unsigned char *)&(EDI);
 			IS_MODE_REG = 1; return(2);
 	}
+	DEBUG_EXIT("------- ref [%p]=%08x\n",MEM_REF,*((unsigned int *)MEM_REF));
 }
 
 
 int
 hsw_modrm_32_byte(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var)
 {
+	DEBUG_ENTRY
 	switch(*(PC+1)) {
 		case MOD_AL_BXSI: 
 			MEM_REF = ALLOW_OVERRIDE(LONG_DS)+(EAX);
@@ -4420,12 +4457,14 @@
 			interp_var->reg1 = &(BH);
 			IS_MODE_REG = 1; return(2);
 	}
+	DEBUG_EXIT("------- ref [%p]=%02x\n",MEM_REF,*((unsigned char *)MEM_REF));
 }
 
 
 int
 hsw_modrm_32_word(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var)
 {
+	DEBUG_ENTRY
 	switch(*(PC+1)) {
 		case MOD_AX_BXSI: 
 			MEM_REF = ALLOW_OVERRIDE(LONG_DS)+(EAX);
@@ -5452,12 +5491,14 @@
 			interp_var->reg1 = (unsigned char *)&(DI);
 			IS_MODE_REG = 1; return(2);
 	}
+	DEBUG_EXIT("------- ref [%p]=%04x\n",MEM_REF,*((unsigned short *)MEM_REF));
 }
 
 
 int
 hsw_modrm_32_quad(Interp_ENV *env, unsigned char *PC, Interp_VAR *interp_var)
 {
+	DEBUG_ENTRY
 	switch(*(PC+1)) {
 		case MOD_AX_BXSI: 
 			MEM_REF = ALLOW_OVERRIDE(LONG_DS)+(EAX);
@@ -6484,4 +6525,5 @@
 			interp_var->reg1 = (unsigned char *)&(EDI);
 			IS_MODE_REG = 1; return(2);
 	}
+	DEBUG_EXIT("------- ref [%p]=%08x\n",MEM_REF,*((unsigned int *)MEM_REF));
 }
diff -urN twin-3.1.1/intp32/mod_rm.h twin/intp32/mod_rm.h
--- twin-3.1.1/intp32/mod_rm.h	Fri Oct 24 16:46:23 1997
+++ twin/intp32/mod_rm.h	Sat Nov  1 21:36:00 1997
@@ -1,20 +1,37 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*************************************************************************
 
 	@(#)mod_rm.h	1.4
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
diff -urN twin-3.1.1/win/BinTypes.h twin/win/BinTypes.h
--- twin-3.1.1/win/BinTypes.h	Fri Oct 24 16:46:23 1997
+++ twin/win/BinTypes.h	Sat Nov  1 21:52:18 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*
 	@(#)BinTypes.h	2.11
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -90,6 +107,7 @@
   } INITT;
 typedef INITT *LPINITT;
 
+#ifndef DOSEMU
 WORD    InitApp(HINSTANCE);
 WORD    WaitEvent(HANDLE);
 
@@ -134,10 +152,12 @@
 #undef  LocalUnlock
 #undef  LocalFree
 #undef  LocalSize
+#endif	/* DOSEMU */
 
 #define SP ((LPBYTE)(envp->reg.sp))
 #define BP ((LPBYTE)(envp->reg.bp))
 
+#ifndef DOSEMU
 #define RECT_TO_86(lp,r) { PUTWORD(lp,(WORD)r.left); \
 	PUTWORD(lp+2,(WORD)r.top); \
 	PUTWORD(lp+4,(WORD)r.right); \
@@ -163,5 +183,6 @@
 #define pStackBottom    0x000e
 
 #define BITMAPINFOHEADER_SIZE_86  40
+#endif	/* DOSEMU */
 
 #endif /* BinTypes__h */
diff -urN twin-3.1.1/win/DPMI.h twin/win/DPMI.h
--- twin-3.1.1/win/DPMI.h	Fri Oct 24 16:46:23 1997
+++ twin/win/DPMI.h	Sat Nov  1 21:52:45 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*
 	@(#)DPMI.h	2.10
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
@@ -32,7 +49,11 @@
 #define DPMI__h
 
 #include "Segment.h"
+#ifdef DOSEMU
+BOOL LoadSegment(UINT);
+#else
 #include "LoadDLL.h"
+#endif	/* DOSEMU */
 
 LPSTR GetAddress(WORD,WORD);
 WORD AssignSelector(LPBYTE,WORD,BYTE,DWORD);
@@ -46,6 +67,33 @@
 
 /* Macros to access fields in LDT table		*/
 
+#ifdef DOSEMU
+#define GetSelectorAddress(w)	(vm86f? (LPBYTE)(w<<4):((LDT[w>>3].w86Flags & DF_PRESENT)? \
+				LDT[w>>3].lpSelBase:(LoadSegment(w)? \
+				LDT[w>>3].lpSelBase:0)))
+
+#define SetPhysicalAddress(w,l) { if (!vm86f) LDT[w>>3].lpSelBase = (LPBYTE)l; }
+
+#define	GetPhysicalAddress(w)	(vm86f? (LPBYTE)(w<<4):LDT[w>>3].lpSelBase)
+
+#define GetSelectorLimit(w)	(vm86f? 0xffff:LDT[w>>3].dwSelLimit)
+#define SetSelectorLimit(w,d)	{ if (!vm86f) LDT[w>>3].dwSelLimit = (DWORD)d; }
+
+#define GetSelectorHandle(w)	(vm86f? 1:LDT[w>>3].hGlobal)
+#define SetSelectorHandle(w,h)	{ if (!vm86f) LDT[w>>3].hGlobal = (HGLOBAL)h;}
+
+#define GetSelectorFlags(w)	(vm86f? 0x00f0:LDT[w>>3].w86Flags)
+#define SetSelectorFlags(w,wf)	{ if (!vm86f) LDT[w>>3].w86Flags = (WORD)wf; }
+
+#define GetSelectorType(w)	(vm86f? 0:LDT[w>>3].bSelType)
+#define SetSelectorType(w,bt)	{ if (!vm86f) LDT[w>>3].w86Flags = Sel86Flags[bt], \
+				  LDT[w>>3].bSelType = (BYTE)bt; }
+
+#define GetModuleIndex(w)	(vm86f? 0:LDT[w>>3].bModIndex)
+#define SetModuleIndex(w,bi)	{ if (!vm86f) LDT[w>>3].bModIndex = (BYTE)bi; }
+
+#else	/* DOSEMU */
+
 #define GetSelectorAddress(w)	((LDT[w>>3].w86Flags & DF_PRESENT)? \
 				LDT[w>>3].lpSelBase:(LoadSegment(w)? \
 				LDT[w>>3].lpSelBase:0))
@@ -69,6 +117,7 @@
 
 #define GetModuleIndex(w)	LDT[w>>3].bModIndex
 #define SetModuleIndex(w,bi)	{ LDT[w>>3].bModIndex = (BYTE)bi; }
+#endif	/* DOSEMU */
 
 #define	CopySelector(w1,w2)	memcpy((LPSTR)&LDT[w1>>3], \
 					(LPSTR)&LDT[w2>>3], \
@@ -129,6 +178,6 @@
 
 extern WORD Sel86Flags[];
 extern DSCR *LDT;
-extern nLDTSize;
+extern int nLDTSize;
 
 #endif /* DPMI__h */
diff -urN twin-3.1.1/win/Endian.h twin/win/Endian.h
--- twin-3.1.1/win/Endian.h	Fri Oct 24 16:46:23 1997
+++ twin/win/Endian.h	Sat Nov  1 21:53:05 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*
 	@(#)Endian.h	2.3
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
diff -urN twin-3.1.1/win/Segment.h twin/win/Segment.h
--- twin-3.1.1/win/Segment.h	Fri Oct 24 16:46:23 1997
+++ twin/win/Segment.h	Sat Nov  1 21:53:28 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*
 	@(#)Segment.h	2.4
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
diff -urN twin-3.1.1/win/WinConfig.h twin/win/WinConfig.h
--- twin-3.1.1/win/WinConfig.h	Fri Oct 24 16:46:23 1997
+++ twin/win/WinConfig.h	Sat Nov  1 21:53:56 1997
@@ -1,21 +1,41 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /********************************************************************
 	@(#)WinConfig.h	1.12 Twin configuration file management.
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
 
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
-not, write to the Free Software Foundation, Inc., 675 Mass Ave,
-Cambridge, MA 02139, USA.
 
 
 For more information about the Willows Twin Libraries.
diff -urN twin-3.1.1/win/utils.h twin/win/utils.h
--- twin-3.1.1/win/utils.h	Thu Jul 17 18:36:27 1997
+++ twin/win/utils.h	Sat Nov  1 22:37:09 1997
@@ -1,19 +1,36 @@
+/* NOTE:
+ * This file was modified for DOSEMU by the DOSEMU-team.
+ * The original is 'Copyright 1997 Willows Software, Inc.' and generously
+ * was put under the GNU Library General Public License.
+ * ( for more information see http://www.willows.com/ )
+ *
+ * We make use of section 3 of the GNU Library General Public License
+ * ('...opt to apply the terms of the ordinary GNU General Public License...'),
+ * because the resulting product is an integrated part of DOSEMU and
+ * can not be considered to be a 'library' in the terms of Library License.
+ * The (below) original copyright notice from Willows therefore was edited
+ * conforming to section 3 of the GNU Library General Public License.
+ *
+ * Nov. 1 1997, The DOSEMU team.
+ */
+
+
 /*************************************************************************
 	@(#)utils.h	2.5
     	Copyright 1997 Willows Software, Inc. 
 
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 
-This library is distributed in the hope that it will be useful,
+This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
+General Public License for more details.
 
-You should have received a copy of the GNU Library General Public
-License along with this library; see the file COPYING.LIB.  If
+You should have received a copy of the GNU General Public
+License along with this program; see the file COPYING.  If
 not, write to the Free Software Foundation, Inc., 675 Mass Ave,
 Cambridge, MA 02139, USA.
 
